{"version":3,"file":"NameThatHand-DWhmrvWv.js","sources":["../../src/lib/poker.ts","../../src/games/foundation/NameThatHand.ts"],"sourcesContent":["/**\n * Poker hand evaluation and utility functions\n */\n\nimport type { Card, BoardTexture, Rank, Suit } from '../types/cards.js';\n\nexport type HandRanking = \n  | 'Royal Flush'\n  | 'Straight Flush'\n  | 'Four of a Kind'\n  | 'Full House'\n  | 'Flush'\n  | 'Straight'\n  | 'Three of a Kind'\n  | 'Two Pair'\n  | 'Pair'\n  | 'High Card';\n\nexport interface HandEvaluation {\n  name: HandRanking;\n  rank: number;\n  cards: string[];\n}\nimport { parseCard, RANKS, SUITS } from './cards.js';\n\n/**\n * Hand rankings from lowest to highest\n */\nexport const HAND_RANKINGS: readonly HandRanking[] = [\n  'High Card',\n  'Pair',\n  'Two Pair',\n  'Three of a Kind',\n  'Straight',\n  'Flush',\n  'Full House',\n  'Four of a Kind',\n  'Straight Flush',\n  'Royal Flush'\n] as const;\n\n/**\n * Get numeric value for a hand ranking (higher is better)\n */\nexport function getHandRankingValue(ranking: HandRanking): number {\n  return HAND_RANKINGS.indexOf(ranking);\n}\n\n/**\n * Compare two hand rankings\n */\nexport function compareHandRankings(a: HandRanking, b: HandRanking): number {\n  return getHandRankingValue(b) - getHandRankingValue(a);\n}\n\n/**\n * Get rank value for comparison (Ace high = 14)\n */\nexport function getRankValue(rank: Rank): number {\n  if (rank === 'A') return 14;\n  if (rank === 'K') return 13;\n  if (rank === 'Q') return 12;\n  if (rank === 'J') return 11;\n  if (rank === 'T') return 10;\n  return parseInt(rank);\n}\n\n/**\n * Check if cards form a flush\n */\nexport function isFlush(cards: (Card | string)[]): boolean {\n  if (cards.length < 5) return false;\n  \n  const parsedCards = cards.map(c => parseCard(c));\n  const suitCounts: Record<Suit, number> = { h: 0, d: 0, c: 0, s: 0 };\n  \n  for (const card of parsedCards) {\n    suitCounts[card.suit]++;\n    if (suitCounts[card.suit] >= 5) return true;\n  }\n  \n  return false;\n}\n\n/**\n * Check if cards form a straight\n */\nexport function isStraight(cards: (Card | string)[]): boolean {\n  if (cards.length < 5) return false;\n  \n  const parsedCards = cards.map(c => parseCard(c));\n  const rankValues = [...new Set(parsedCards.map(c => getRankValue(c.rank)))].sort((a, b) => b - a);\n  \n  // Check for regular straights\n  for (let i = 0; i <= rankValues.length - 5; i++) {\n    let isStraight = true;\n    for (let j = 0; j < 4; j++) {\n      if (rankValues[i + j] - rankValues[i + j + 1] !== 1) {\n        isStraight = false;\n        break;\n      }\n    }\n    if (isStraight) return true;\n  }\n  \n  // Check for A-2-3-4-5 (wheel)\n  const hasAce = rankValues.includes(14);\n  const hasTwo = rankValues.includes(2);\n  const hasThree = rankValues.includes(3);\n  const hasFour = rankValues.includes(4);\n  const hasFive = rankValues.includes(5);\n  \n  return hasAce && hasTwo && hasThree && hasFour && hasFive;\n}\n\n/**\n * Check if cards form a straight flush\n */\nexport function isStraightFlush(cards: (Card | string)[]): boolean {\n  if (cards.length < 5) return false;\n  \n  const parsedCards = cards.map(c => parseCard(c));\n  const bySuit: Record<Suit, Card[]> = { h: [], d: [], c: [], s: [] };\n  \n  for (const card of parsedCards) {\n    bySuit[card.suit].push(card);\n  }\n  \n  for (const suit of SUITS) {\n    if (bySuit[suit].length >= 5) {\n      const suitCards = bySuit[suit].map(c => c.rank + c.suit);\n      if (isStraight(suitCards)) return true;\n    }\n  }\n  \n  return false;\n}\n\n/**\n * Count occurrences of each rank\n */\nexport function countRanks(cards: (Card | string)[]): Map<Rank, number> {\n  const counts = new Map<Rank, number>();\n  \n  for (const card of cards) {\n    const parsed = parseCard(card);\n    counts.set(parsed.rank, (counts.get(parsed.rank) || 0) + 1);\n  }\n  \n  return counts;\n}\n\n/**\n * Get pairs from cards\n */\nexport function getPairs(cards: (Card | string)[]): Rank[] {\n  const counts = countRanks(cards);\n  const pairs: Rank[] = [];\n  \n  for (const [rank, count] of counts) {\n    if (count === 2) pairs.push(rank);\n  }\n  \n  return pairs.sort((a, b) => getRankValue(b) - getRankValue(a));\n}\n\n/**\n * Get three of a kinds from cards\n */\nexport function getThreeOfAKinds(cards: (Card | string)[]): Rank[] {\n  const counts = countRanks(cards);\n  const threes: Rank[] = [];\n  \n  for (const [rank, count] of counts) {\n    if (count === 3) threes.push(rank);\n  }\n  \n  return threes.sort((a, b) => getRankValue(b) - getRankValue(a));\n}\n\n/**\n * Get four of a kinds from cards\n */\nexport function getFourOfAKinds(cards: (Card | string)[]): Rank[] {\n  const counts = countRanks(cards);\n  const fours: Rank[] = [];\n  \n  for (const [rank, count] of counts) {\n    if (count === 4) fours.push(rank);\n  }\n  \n  return fours.sort((a, b) => getRankValue(b) - getRankValue(a));\n}\n\n/**\n * Simple hand evaluation (basic, not complete poker evaluation)\n * For complete evaluation, use pokersolver library in production\n */\nexport function evaluateHand(cards: (Card | string)[]): HandEvaluation {\n  const parsedCards = cards.map(c => parseCard(c));\n  const cardStrings = parsedCards.map(c => c.toString());\n  \n  if (cards.length < 5) {\n    return { name: 'High Card', rank: 1, cards: cardStrings };\n  }\n  \n  const isRoyalFlush = isStraightFlush(cards) && cards.some(c => {\n    const parsed = parseCard(c);\n    return parsed.rank === 'A';\n  });\n  \n  if (isRoyalFlush) return { name: 'Royal Flush', rank: 10, cards: cardStrings };\n  if (isStraightFlush(cards)) return { name: 'Straight Flush', rank: 9, cards: cardStrings };\n  \n  const fours = getFourOfAKinds(cards);\n  if (fours.length > 0) return { name: 'Four of a Kind', rank: 8, cards: cardStrings };\n  \n  const threes = getThreeOfAKinds(cards);\n  const pairs = getPairs(cards);\n  \n  if (threes.length > 0 && pairs.length > 0) return { name: 'Full House', rank: 7, cards: cardStrings };\n  if (isFlush(cards)) return { name: 'Flush', rank: 6, cards: cardStrings };\n  if (isStraight(cards)) return { name: 'Straight', rank: 5, cards: cardStrings };\n  if (threes.length > 0) return { name: 'Three of a Kind', rank: 4, cards: cardStrings };\n  if (pairs.length >= 2) return { name: 'Two Pair', rank: 3, cards: cardStrings };\n  if (pairs.length === 1) return { name: 'Pair', rank: 2, cards: cardStrings };\n  \n  return { name: 'High Card', rank: 1, cards: cardStrings };\n}\n\n/**\n * Analyze board texture for strategic considerations\n */\nexport function analyzeBoardTexture(communityCards: (Card | string)[]): BoardTexture {\n  const parsedCards = communityCards.map(c => parseCard(c));\n  const suitCounts: Record<Suit, number> = { h: 0, d: 0, c: 0, s: 0 };\n  const rankCounts = countRanks(parsedCards);\n  \n  for (const card of parsedCards) {\n    suitCounts[card.suit]++;\n  }\n  \n  const maxSuitCount = Math.max(...Object.values(suitCounts));\n  const uniqueSuits = Object.values(suitCounts).filter(c => c > 0).length;\n  const sortedRanks = parsedCards.map(c => c.rank).sort((a, b) => getRankValue(b) - getRankValue(a));\n  \n  return {\n    isFlushPossible: maxSuitCount >= 3,\n    isStraightPossible: checkStraightPossibility(parsedCards),\n    isPaired: Array.from(rankCounts.values()).some(c => c >= 2),\n    isMonotone: uniqueSuits === 1,\n    isRainbow: uniqueSuits === parsedCards.length && parsedCards.length <= 4,\n    highCard: sortedRanks[0],\n    possibleStraights: findPossibleStraights(parsedCards),\n    possibleFlushes: (Object.entries(suitCounts) as [Suit, number][])\n      .filter(([_, count]) => count >= 3)\n      .map(([suit]) => suit)\n  };\n}\n\n/**\n * Check if a straight is possible with the given cards\n */\nfunction checkStraightPossibility(cards: Card[]): boolean {\n  if (cards.length < 3) return false;\n  \n  const rankValues = [...new Set(cards.map(c => getRankValue(c.rank)))].sort((a, b) => a - b);\n  \n  // Check for gaps\n  for (let i = 0; i < rankValues.length - 2; i++) {\n    const gap1 = rankValues[i + 1] - rankValues[i];\n    const gap2 = rankValues[i + 2] - rankValues[i + 1];\n    if (gap1 <= 4 && gap2 <= 4) return true;\n  }\n  \n  // Check wheel possibility\n  const hasLowCards = rankValues.some(v => v <= 5);\n  const hasAce = rankValues.includes(14);\n  if (hasLowCards && hasAce) return true;\n  \n  return false;\n}\n\n/**\n * Find possible straights that could be made\n */\nfunction findPossibleStraights(cards: Card[]): string[] {\n  const straights: string[] = [];\n  const rankValues = [...new Set(cards.map(c => getRankValue(c.rank)))];\n  \n  // Check each possible 5-card straight\n  for (let start = 2; start <= 10; start++) {\n    const needed: number[] = [];\n    let have = 0;\n    \n    for (let i = 0; i < 5; i++) {\n      const rank = start + i;\n      if (rankValues.includes(rank)) {\n        have++;\n      } else {\n        needed.push(rank);\n      }\n    }\n    \n    if (have >= 3 && needed.length <= 2) {\n      const straightName = start === 10 ? 'Broadway' : `${start} to ${start + 4}`;\n      straights.push(straightName);\n    }\n  }\n  \n  // Check wheel (A-2-3-4-5)\n  const wheelRanks = [14, 2, 3, 4, 5];\n  const wheelHave = wheelRanks.filter(r => rankValues.includes(r)).length;\n  if (wheelHave >= 3) {\n    straights.push('Wheel (A-5)');\n  }\n  \n  return straights;\n}\n\n/**\n * Get hand description string\n */\nexport function getHandDescription(ranking: HandRanking, cards: (Card | string)[]): string {\n  const parsedCards = cards.map(c => parseCard(c));\n  \n  switch (ranking) {\n    case 'Royal Flush':\n      return 'Royal Flush';\n    \n    case 'Straight Flush': {\n      const highCard = parsedCards.sort((a, b) => getRankValue(b.rank) - getRankValue(a.rank))[0];\n      return `Straight Flush, ${highCard.displayRank} high`;\n    }\n    \n    case 'Four of a Kind': {\n      const fours = getFourOfAKinds(cards);\n      return `Four ${fours[0]}s`;\n    }\n    \n    case 'Full House': {\n      const threes = getThreeOfAKinds(cards);\n      const pairs = getPairs(cards);\n      return `Full House, ${threes[0]}s full of ${pairs[0]}s`;\n    }\n    \n    case 'Flush': {\n      const highCard = parsedCards.sort((a, b) => getRankValue(b.rank) - getRankValue(a.rank))[0];\n      return `Flush, ${highCard.displayRank} high`;\n    }\n    \n    case 'Straight': {\n      const highCard = parsedCards.sort((a, b) => getRankValue(b.rank) - getRankValue(a.rank))[0];\n      return `Straight, ${highCard.displayRank} high`;\n    }\n    \n    case 'Three of a Kind': {\n      const threes = getThreeOfAKinds(cards);\n      return `Three ${threes[0]}s`;\n    }\n    \n    case 'Two Pair': {\n      const pairs = getPairs(cards);\n      return `Two Pair, ${pairs[0]}s and ${pairs[1]}s`;\n    }\n    \n    case 'Pair': {\n      const pairs = getPairs(cards);\n      return `Pair of ${pairs[0]}s`;\n    }\n    \n    default: {\n      const highCard = parsedCards.sort((a, b) => getRankValue(b.rank) - getRankValue(a.rank))[0];\n      return `${highCard.displayRank} high`;\n    }\n  }\n}\n\n/**\n * Compare two hands and return winner\n * Returns: positive if hand1 wins, negative if hand2 wins, 0 if tie\n */\nexport function compareHands(hand1: (Card | string)[], hand2: (Card | string)[]): number {\n  const eval1 = evaluateHand(hand1);\n  const eval2 = evaluateHand(hand2);\n  \n  if (eval1.rank !== eval2.rank) {\n    return eval1.rank - eval2.rank;\n  }\n  \n  // If same hand type, compare the actual cards\n  const cards1 = hand1.map(c => parseCard(c));\n  const cards2 = hand2.map(c => parseCard(c));\n  \n  // Compare based on hand type\n  switch (eval1.name) {\n    case 'Four of a Kind': {\n      const quads1 = getFourOfAKinds(cards1)[0];\n      const quads2 = getFourOfAKinds(cards2)[0];\n      const quadComp = getRankValue(quads1) - getRankValue(quads2);\n      if (quadComp !== 0) return quadComp;\n      break;\n    }\n    \n    case 'Full House': {\n      const trips1 = getThreeOfAKinds(cards1)[0];\n      const trips2 = getThreeOfAKinds(cards2)[0];\n      const tripComp = getRankValue(trips1) - getRankValue(trips2);\n      if (tripComp !== 0) return tripComp;\n      \n      const pairs1 = getPairs(cards1)[0];\n      const pairs2 = getPairs(cards2)[0];\n      return getRankValue(pairs1) - getRankValue(pairs2);\n    }\n    \n    case 'Flush':\n    case 'Straight':\n    case 'High Card': {\n      // Compare high cards\n      const sorted1 = cards1.sort((a, b) => getRankValue(b.rank) - getRankValue(a.rank));\n      const sorted2 = cards2.sort((a, b) => getRankValue(b.rank) - getRankValue(a.rank));\n      \n      for (let i = 0; i < Math.min(sorted1.length, sorted2.length); i++) {\n        const comp = getRankValue(sorted1[i].rank) - getRankValue(sorted2[i].rank);\n        if (comp !== 0) return comp;\n      }\n      break;\n    }\n    \n    case 'Three of a Kind': {\n      const trips1 = getThreeOfAKinds(cards1)[0];\n      const trips2 = getThreeOfAKinds(cards2)[0];\n      const comp = getRankValue(trips1) - getRankValue(trips2);\n      if (comp !== 0) return comp;\n      \n      // Compare kickers\n      const kickers1 = cards1.filter(c => c.rank !== trips1).sort((a, b) => getRankValue(b.rank) - getRankValue(a.rank));\n      const kickers2 = cards2.filter(c => c.rank !== trips2).sort((a, b) => getRankValue(b.rank) - getRankValue(a.rank));\n      \n      for (let i = 0; i < Math.min(kickers1.length, kickers2.length); i++) {\n        const kickerComp = getRankValue(kickers1[i].rank) - getRankValue(kickers2[i].rank);\n        if (kickerComp !== 0) return kickerComp;\n      }\n      break;\n    }\n    \n    case 'Two Pair': {\n      const pairs1 = getPairs(cards1);\n      const pairs2 = getPairs(cards2);\n      \n      // Compare high pair\n      const highPairComp = getRankValue(pairs1[0]) - getRankValue(pairs2[0]);\n      if (highPairComp !== 0) return highPairComp;\n      \n      // Compare low pair\n      const lowPairComp = getRankValue(pairs1[1]) - getRankValue(pairs2[1]);\n      if (lowPairComp !== 0) return lowPairComp;\n      \n      // Compare kicker\n      const kicker1 = cards1.find(c => !pairs1.includes(c.rank));\n      const kicker2 = cards2.find(c => !pairs2.includes(c.rank));\n      if (kicker1 && kicker2) {\n        return getRankValue(kicker1.rank) - getRankValue(kicker2.rank);\n      }\n      break;\n    }\n    \n    case 'Pair': {\n      const pair1 = getPairs(cards1)[0];\n      const pair2 = getPairs(cards2)[0];\n      const pairComp = getRankValue(pair1) - getRankValue(pair2);\n      if (pairComp !== 0) return pairComp;\n      \n      // Compare kickers\n      const kickers1 = cards1.filter(c => c.rank !== pair1).sort((a, b) => getRankValue(b.rank) - getRankValue(a.rank));\n      const kickers2 = cards2.filter(c => c.rank !== pair2).sort((a, b) => getRankValue(b.rank) - getRankValue(a.rank));\n      \n      for (let i = 0; i < Math.min(kickers1.length, kickers2.length); i++) {\n        const kickerComp = getRankValue(kickers1[i].rank) - getRankValue(kickers2[i].rank);\n        if (kickerComp !== 0) return kickerComp;\n      }\n      break;\n    }\n  }\n  \n  return 0;\n}\n\n/**\n * Get numeric rank for a hand evaluation\n */\nexport function getHandRank(evaluation: HandEvaluation): number {\n  return evaluation.rank;\n}\n\n/**\n * Generate a specific hand type for training games\n */\nexport function generateHandType(type: HandRanking, deck: string[]): string[] | null {\n  const shuffled = [...deck];\n  \n  // This is a simplified version - in production, use more sophisticated generation\n  // or integrate with pokersolver for accurate hand generation\n  \n  switch (type) {\n    case 'Pair':\n      return findHandWithPairs(shuffled, 1);\n    \n    case 'Two Pair':\n      return findHandWithPairs(shuffled, 2);\n    \n    case 'Three of a Kind':\n      return findHandWithTrips(shuffled);\n    \n    case 'Straight':\n      return findStraight(shuffled);\n    \n    case 'Flush':\n      return findFlush(shuffled);\n    \n    case 'Full House':\n      return findFullHouse(shuffled);\n    \n    case 'Four of a Kind':\n      return findQuads(shuffled);\n    \n    case 'Straight Flush':\n      return findStraightFlush(shuffled);\n    \n    case 'Royal Flush':\n      return findRoyalFlush(shuffled);\n    \n    default:\n      return shuffled.slice(0, 5);\n  }\n}\n\n// Helper functions for hand generation\nfunction findHandWithPairs(deck: string[], pairCount: number): string[] | null {\n  const hand: string[] = [];\n  const usedRanks = new Set<Rank>();\n  \n  for (let i = 0; i < pairCount; i++) {\n    const rank = RANKS.find(r => !usedRanks.has(r));\n    if (!rank) return null;\n    \n    const cards = deck.filter(c => parseCard(c).rank === rank).slice(0, 2);\n    if (cards.length < 2) return null;\n    \n    hand.push(...cards);\n    usedRanks.add(rank);\n  }\n  \n  // Fill remaining cards\n  while (hand.length < 5) {\n    const card = deck.find(c => !hand.includes(c) && !usedRanks.has(parseCard(c).rank));\n    if (!card) return null;\n    hand.push(card);\n    usedRanks.add(parseCard(card).rank);\n  }\n  \n  return hand;\n}\n\nfunction findHandWithTrips(deck: string[]): string[] | null {\n  for (const rank of RANKS) {\n    const cards = deck.filter(c => parseCard(c).rank === rank);\n    if (cards.length >= 3) {\n      const hand = cards.slice(0, 3);\n      const others = deck.filter(c => parseCard(c).rank !== rank).slice(0, 2);\n      return [...hand, ...others];\n    }\n  }\n  return null;\n}\n\nfunction findStraight(deck: string[]): string[] | null {\n  // Simplified - just return any 5 consecutive ranks if possible\n  const sortedByRank = deck.sort((a, b) => getRankValue(parseCard(b).rank) - getRankValue(parseCard(a).rank));\n  return sortedByRank.slice(0, 5);\n}\n\nfunction findFlush(deck: string[]): string[] | null {\n  for (const suit of SUITS) {\n    const cards = deck.filter(c => parseCard(c).suit === suit);\n    if (cards.length >= 5) {\n      return cards.slice(0, 5);\n    }\n  }\n  return null;\n}\n\nfunction findFullHouse(deck: string[]): string[] | null {\n  const trips = findHandWithTrips(deck);\n  if (!trips) return null;\n  \n  const tripRank = parseCard(trips[0]).rank;\n  const pair = deck.filter(c => {\n    const rank = parseCard(c).rank;\n    return rank !== tripRank;\n  }).slice(0, 2);\n  \n  if (pair.length < 2) return null;\n  \n  return [...trips.slice(0, 3), ...pair];\n}\n\nfunction findQuads(deck: string[]): string[] | null {\n  for (const rank of RANKS) {\n    const cards = deck.filter(c => parseCard(c).rank === rank);\n    if (cards.length === 4) {\n      const kicker = deck.find(c => parseCard(c).rank !== rank);\n      return [...cards, kicker!];\n    }\n  }\n  return null;\n}\n\nfunction findStraightFlush(deck: string[]): string[] | null {\n  // Simplified - would need more complex logic in production\n  return findFlush(deck);\n}\n\nfunction findRoyalFlush(deck: string[]): string[] | null {\n  // Simplified - would need specific royal flush logic in production\n  for (const suit of SUITS) {\n    const royalRanks = ['T', 'J', 'Q', 'K', 'A'];\n    const cards = royalRanks.map(r => r + suit);\n    if (cards.every(c => deck.includes(c))) {\n      return cards;\n    }\n  }\n  return null;\n}","/**\n * Name That Hand - Foundation level game\n * Players identify poker hands from 5 cards\n */\n\nimport { BaseGame } from '../BaseGame.js';\nimport type { GameConfig, GameScenario, Choice } from '../../types/games.js';\nimport type { HandRanking } from '../../types/cards.js';\nimport { \n  generateDeck, \n  renderCards\n} from '../../lib/cards.js';\nimport { \n  HAND_RANKINGS, \n  generateHandType, \n  evaluateHand\n} from '../../lib/poker.js';\nimport { shuffleArray } from '../../lib/random.js';\n\nexport class NameThatHand extends BaseGame {\n  private targetHandTypes: HandRanking[] = [];\n  \n  constructor() {\n    const config: GameConfig = {\n      name: 'Name That Hand',\n      difficulty: 'foundation',\n      rounds: 30,\n      description: 'Identify poker hands from 5 cards',\n      instructions: [\n        'Look at the 5 cards shown',\n        'Identify what poker hand they make',\n        'Select the correct hand name from the choices',\n        'Learn to recognize all 10 hand types'\n      ]\n    };\n    \n    super(config);\n  }\n  \n  protected generateScenarios(): GameScenario[] {\n    const scenarios: GameScenario[] = [];\n    \n    // Generate 3 of each hand type for even distribution\n    this.targetHandTypes = [];\n    for (let i = 0; i < 3; i++) {\n      this.targetHandTypes.push(...HAND_RANKINGS);\n    }\n    \n    // Shuffle the order\n    this.targetHandTypes = shuffleArray(this.targetHandTypes);\n    \n    // Generate a scenario for each target hand\n    for (let i = 0; i < this.config.rounds; i++) {\n      const targetHand = this.targetHandTypes[i];\n      const deck = generateDeck({ shuffled: true });\n      \n      // Try to generate the specific hand type\n      let cards = generateHandType(targetHand, deck);\n      \n      // If generation failed, use a shuffled hand\n      if (!cards) {\n        cards = deck.slice(0, 5);\n      }\n      \n      // Create choices - the correct answer plus 3 wrong ones\n      const evaluation = evaluateHand(cards);\n      const correctAnswer = evaluation.name;\n      const choices = this.generateChoices(correctAnswer as HandRanking);\n      \n      scenarios.push({\n        id: `round-${i + 1}`,\n        correctAnswer,\n        choices,\n        communityCards: { \n          flop: [cards[0], cards[1], cards[2]],\n          turn: cards[3],\n          river: cards[4]\n        }\n      });\n      \n    }\n    \n    return scenarios;\n  }\n  \n  private generateChoices(correctAnswer: HandRanking): Choice[] {\n    const choices: Choice[] = [];\n    const allRankings = [...HAND_RANKINGS];\n    \n    // Add the correct answer\n    choices.push({\n      id: correctAnswer,\n      display: correctAnswer,\n      value: correctAnswer\n    });\n    \n    // Remove correct answer from possibilities\n    const wrongChoices = allRankings.filter(r => r !== correctAnswer);\n    \n    // Pick 3 random wrong answers\n    const selectedWrong = shuffleArray(wrongChoices).slice(0, 3);\n    \n    for (const wrong of selectedWrong) {\n      choices.push({\n        id: wrong,\n        display: wrong,\n        value: wrong\n      });\n    }\n    \n    // Shuffle all choices\n    return shuffleArray(choices);\n  }\n  \n  protected renderScenario(): void {\n    if (!this.currentScenario || !this.container) return;\n    \n    const gameArea = this.container.querySelector('#game-area');\n    if (!gameArea) return;\n    \n    // Get the cards from the scenario\n    const cards: string[] = [];\n    if (this.currentScenario.communityCards) {\n      const { flop, turn, river } = this.currentScenario.communityCards;\n      if (flop) cards.push(...flop as string[]);\n      if (turn) cards.push(turn as string);\n      if (river) cards.push(river as string);\n    }\n    \n    gameArea.innerHTML = `\n      <div class=\"round-info\">\n        <h3>Round ${this.state.currentRound} of ${this.state.totalRounds}</h3>\n        <p>What poker hand do these cards make?</p>\n      </div>\n      \n      <div class=\"cards-display\" id=\"cards-display\"></div>\n      \n      <div class=\"choices-container\" id=\"choices-container\"></div>\n      \n      <div class=\"feedback\" id=\"feedback\" style=\"display: none;\"></div>\n    `;\n    \n    // Render the cards\n    const cardsContainer = gameArea.querySelector('#cards-display');\n    if (cardsContainer) {\n      renderCards(cards, cardsContainer as HTMLElement, {\n        width: 80,\n        height: 115,\n        style: 'simple'\n      });\n    }\n    \n    // Render choices\n    const choicesContainer = gameArea.querySelector('#choices-container');\n    if (choicesContainer && this.currentScenario.choices) {\n      choicesContainer.innerHTML = '';\n      \n      for (const choice of this.currentScenario.choices) {\n        const button = document.createElement('button');\n        button.className = 'choice-btn';\n        button.textContent = choice.display || '';\n        button.onclick = () => this.submitAnswer(choice.value);\n        choicesContainer.appendChild(button);\n      }\n    }\n  }\n  \n  protected renderGame(): void {\n    // Additional game-specific UI setup if needed\n    this.addStyles();\n  }\n  \n  protected checkAnswer(answer: any, correctAnswer: any): boolean {\n    return answer === correctAnswer;\n  }\n  \n  protected handleAnswerFeedback(isCorrect: boolean, answer: any): void {\n    const feedback = this.container?.querySelector('#feedback') as HTMLElement;\n    if (!feedback) return;\n    \n    const choiceButtons = this.container?.querySelectorAll('.choice-btn');\n    choiceButtons?.forEach(btn => {\n      const button = btn as HTMLButtonElement;\n      button.disabled = true;\n      \n      if (button.textContent === this.currentScenario?.correctAnswer) {\n        button.classList.add('correct');\n      } else if (button.textContent === answer) {\n        button.classList.add('incorrect');\n      }\n    });\n    \n    feedback.style.display = 'block';\n    feedback.className = `feedback ${isCorrect ? 'correct' : 'incorrect'}`;\n    feedback.innerHTML = isCorrect \n      ? '✓ Correct! Well done!' \n      : `✗ That's ${answer}. The correct answer is ${this.currentScenario?.correctAnswer}.`;\n  }\n  \n  private addStyles(): void {\n    if (document.getElementById('name-that-hand-styles')) return;\n    \n    const style = document.createElement('style');\n    style.id = 'name-that-hand-styles';\n    style.textContent = `\n      .round-info {\n        text-align: center;\n        margin-bottom: 30px;\n      }\n      \n      .round-info h3 {\n        color: #7D1346;\n        margin-bottom: 10px;\n      }\n      \n      .cards-display {\n        display: flex;\n        justify-content: center;\n        gap: 10px;\n        margin: 30px 0;\n        flex-wrap: wrap;\n      }\n      \n      .choices-container {\n        display: grid;\n        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n        gap: 15px;\n        margin: 30px auto;\n        max-width: 600px;\n      }\n      \n      .choice-btn {\n        padding: 15px 20px;\n        border: 2px solid #C73E9A;\n        border-radius: 10px;\n        background: white;\n        color: #C73E9A;\n        font-size: 1.1em;\n        font-weight: 600;\n        cursor: pointer;\n        transition: all 0.3s ease;\n      }\n      \n      .choice-btn:hover:not(:disabled) {\n        background: #C73E9A;\n        color: white;\n        transform: translateY(-2px);\n      }\n      \n      .choice-btn:disabled {\n        cursor: not-allowed;\n        opacity: 0.7;\n      }\n      \n      .choice-btn.correct {\n        background: #4CAF50;\n        border-color: #4CAF50;\n        color: white;\n      }\n      \n      .choice-btn.incorrect {\n        background: #f44336;\n        border-color: #f44336;\n        color: white;\n      }\n      \n      .feedback {\n        text-align: center;\n        padding: 15px;\n        border-radius: 10px;\n        margin: 20px auto;\n        max-width: 500px;\n        font-size: 1.1em;\n        font-weight: 600;\n      }\n      \n      .feedback.correct {\n        background: #e8f5e9;\n        color: #2e7d32;\n      }\n      \n      .feedback.incorrect {\n        background: #ffebee;\n        color: #c62828;\n      }\n    `;\n    \n    document.head.appendChild(style);\n  }\n}"],"names":["HAND_RANKINGS","getRankValue","rank","parseInt","isStraight","cards","length","parsedCards","map","c","parseCard","rankValues","Set","sort","a","b","i","j","hasAce","includes","hasTwo","hasThree","hasFour","hasFive","isStraightFlush","bySuit","h","d","s","card","suit","push","SUITS","countRanks","counts","Map","parsed","set","get","evaluateHand","cardStrings","toString","name","some","fours","count","getFourOfAKinds","threes","getThreeOfAKinds","pairs","getPairs","suitCounts","isFlush","generateHandType","type","deck","shuffled","findHandWithPairs","findHandWithTrips","sortedByRank","slice","findStraight","findFlush","trips","tripRank","pair","filter","findFullHouse","RANKS","kicker","find","findQuads","findStraightFlush","r","every","findRoyalFlush","pairCount","hand","usedRanks","has","add","NameThatHand","BaseGame","constructor","super","difficulty","rounds","description","instructions","this","targetHandTypes","generateScenarios","scenarios","shuffleArray","config","targetHand","generateDeck","correctAnswer","choices","generateChoices","id","communityCards","flop","turn","river","allRankings","display","value","wrongChoices","selectedWrong","wrong","renderScenario","currentScenario","container","gameArea","querySelector","innerHTML","state","currentRound","totalRounds","cardsContainer","renderCards","width","height","style","choicesContainer","choice","button","document","createElement","className","textContent","onclick","submitAnswer","appendChild","renderGame","addStyles","checkAnswer","answer","handleAnswerFeedback","isCorrect","feedback","choiceButtons","querySelectorAll","forEach","btn","disabled","classList","getElementById","head"],"mappings":"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"}