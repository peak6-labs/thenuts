<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Nuts - Poker Training Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #6B2B9E 0%, #9C27B0 50%, #CE93D8 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: #FAFAFA;
            border-radius: 20px;
            padding: 30px;
            max-width: 800px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(107, 43, 158, 0.3);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .title {
            font-size: 32px;
            font-weight: 800;
            color: #6B2B9E;
            letter-spacing: -0.5px;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .help-btn, .new-game-btn {
            background: #9C27B0;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(156, 39, 176, 0.3);
        }

        .help-btn:hover, .new-game-btn:hover {
            background: #7B1FA2;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.4);
        }

        .help-btn {
            width: 40px;
            height: 40px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border-radius: 50%;
            background: #E1BEE7;
            color: #6B2B9E;
            box-shadow: 0 2px 8px rgba(107, 43, 158, 0.2);
        }

        .help-btn:hover {
            background: #CE93D8;
            color: white;
        }

        .timer-display {
            font-size: 22px;
            font-weight: 700;
            color: #D32F2F;
            min-width: 70px;
            display: inline-block;
            text-align: center;
            background: #FFEBEE;
            padding: 5px 10px;
            border-radius: 20px;
            transition: background 0.3s, color 0.3s;
        }
        
        .timer-display.paused {
            background: #FFE0B2;
            color: #E65100;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .score-display {
            font-size: 18px;
            font-weight: 600;
            color: #6B2B9E;
            margin-left: 15px;
            background: #F3E5F5;
            padding: 5px 15px;
            border-radius: 20px;
        }

        .cards-area {
            margin-bottom: 25px;
        }

        .section-label {
            font-size: 13px;
            color: #9C27B0;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
        }

        .cards {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .card {
            width: 75px;
            height: 105px;
            border: none;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: white;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s;
            position: relative;
        }

        .card:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 8px 20px rgba(107, 43, 158, 0.25);
        }

        .card.red {
            color: #E91E63;
        }

        .card.black {
            color: #424242;
        }

        .card-rank {
            font-size: 32px;
            font-weight: 700;
            line-height: 1;
        }

        .card-suit {
            font-size: 28px;
            margin-top: 2px;
        }

        .choices {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 25px;
        }

        .choice-btn {
            padding: 18px;
            border: 2px solid #CE93D8;
            background: white;
            border-radius: 15px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        /* Only apply hover on non-touch devices */
        @media (hover: hover) {
            .choice-btn:hover {
                background: linear-gradient(135deg, #9C27B0, #AB47BC);
                color: white;
                border-color: #9C27B0;
                transform: translateY(-3px);
                box-shadow: 0 6px 20px rgba(156, 39, 176, 0.3);
            }
        }

        .choice-btn.correct {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            border-color: #4CAF50;
        }

        .choice-btn.incorrect {
            background: linear-gradient(135deg, #F44336, #EF5350);
            color: white;
            border-color: #F44336;
        }

        .choice-btn:disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        /* Color card symbols in buttons */
        .choice-btn .card-heart,
        .choice-btn .card-diamond {
            color: #dc3545;
        }
        
        .choice-btn .card-spade,
        .choice-btn .card-club {
            color: #212529;
        }
        
        /* Keep colors visible when button is selected */
        .choice-btn.correct .card-heart,
        .choice-btn.correct .card-diamond,
        .choice-btn.incorrect .card-heart,
        .choice-btn.incorrect .card-diamond {
            color: #ffcdd2;
        }
        
        .choice-btn.correct .card-spade,
        .choice-btn.correct .card-club,
        .choice-btn.incorrect .card-spade,
        .choice-btn.incorrect .card-club {
            color: rgba(255, 255, 255, 0.9);
        }

        /* Prevent sticky focus/active states on mobile */
        .choice-btn:focus {
            outline: none;
        }

        .choice-btn:active {
            transform: translateY(-1px);
        }

        /* Remove tap highlight on mobile */
        .choice-btn {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        /* When modal is shown, use flex to center it */
        .modal[style*="display: block"] {
            display: flex !important;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 35px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(107, 43, 158, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 28px;
            color: #6B2B9E;
            font-weight: 800;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 32px;
            cursor: pointer;
            color: #CE93D8;
            transition: color 0.3s;
        }

        .close-btn:hover {
            color: #9C27B0;
        }

        .modal-body {
            line-height: 1.6;
            color: #34495e;
        }

        .modal-body h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #6B2B9E;
            font-weight: 700;
        }

        .modal-body ul {
            margin-left: 20px;
        }

        .game-over {
            text-align: center;
            padding: 25px;
            background: linear-gradient(135deg, #F3E5F5, #FCE4EC);
            border-radius: 15px;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(107, 43, 158, 0.1);
        }

        .game-over h2 {
            color: #6B2B9E;
            margin-bottom: 15px;
            font-size: 28px;
            font-weight: 800;
        }

        .game-over p {
            color: #7f8c8d;
            margin-bottom: 15px;
        }

        .share-btn {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 0 5px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .share-btn:hover {
            background: linear-gradient(135deg, #388E3C, #4CAF50);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .copied-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #6B2B9E, #9C27B0);
            color: white;
            padding: 14px 28px;
            border-radius: 25px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 2000;
            box-shadow: 0 6px 20px rgba(107, 43, 158, 0.4);
            font-weight: 600;
        }

        .copied-toast.show {
            opacity: 1;
        }
        
        /* Progress Dots Styles */
        .progress-dots {
            display: flex;
            justify-content: center;
            gap: 4px;
            padding: 10px 0;
            margin-top: 5px;
        }
        
        .progress-dots .dot {
            font-size: 18px;
            line-height: 1;
            transition: all 0.3s ease;
        }
        
        .progress-dots .dot.correct {
            color: #4CAF50;
        }
        
        .progress-dots .dot.incorrect {
            color: #f44336;
        }
        
        @media (max-width: 480px) {
            .progress-dots {
                gap: 2px;
            }
            
            .progress-dots .dot {
                font-size: 16px;
            }
        }
        
        .hint-text {
            margin-top: 10px;
            padding: 10px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 10px;
            color: #388E3C;
            font-weight: 600;
            text-align: center;
            font-size: 14px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }

        @media (max-width: 600px) {
            .game-container {
                padding: 15px;
            }

            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            .title {
                font-size: 24px;
            }

            .controls {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
            }

            .timer-display {
                font-size: 18px;
                min-width: 65px;
                padding: 4px 8px;
            }

            .score-display {
                font-size: 14px;
                padding: 4px 10px;
            }

            .card {
                width: 60px;
                height: 85px;
            }

            .card-rank {
                font-size: 24px;
            }

            .card-suit {
                font-size: 20px;
            }

            .choices {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <!-- Load pokersolver library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/pokersolver@2.1.4/pokersolver.min.js"></script>
    <!-- Version: 2.0 - Purple Theme Update -->
</head>
<body>
    <div class="game-container">
        <div id="loading" class="loading">Loading poker library...</div>
        
        <div id="game-content" style="display: none;">
            <div class="header">
                <h1 class="title">Find The Nuts!</h1>
                <div class="controls">
                    <div class="timer-display" id="countdown" onclick="togglePause()" style="cursor: pointer;" title="Click to pause/unpause">Level 1 ‚Ä¢ 60.0s</div>
                    <div class="score-display">Correct: <span id="score">0</span></div>
                    <button class="help-btn" onclick="showHelp()">?</button>
                    <button class="new-game-btn" onclick="startNewGame()">New Game</button>
                </div>
                <div class="progress-dots" id="progress-dots">
                    <span class="dot" data-index="0">‚óã</span>
                    <span class="dot" data-index="1">‚óã</span>
                    <span class="dot" data-index="2">‚óã</span>
                    <span class="dot" data-index="3">‚óã</span>
                    <span class="dot" data-index="4">‚óã</span>
                    <span class="dot" data-index="5">‚óã</span>
                    <span class="dot" data-index="6">‚óã</span>
                    <span class="dot" data-index="7">‚óã</span>
                    <span class="dot" data-index="8">‚óã</span>
                    <span class="dot" data-index="9">‚óã</span>
                    <span class="dot" data-index="10">‚óã</span>
                    <span class="dot" data-index="11">‚óã</span>
                    <span class="dot" data-index="12">‚óã</span>
                    <span class="dot" data-index="13">‚óã</span>
                    <span class="dot" data-index="14">‚óã</span>
                </div>
            </div>

            <div class="cards-area">
                <div class="section-label">Community Cards</div>
                <div class="cards" id="community-cards"></div>
            </div>

            <div class="choices-area" id="choices-area">
                <div class="section-label">What is the nuts? (The best possible hand ANY player could have)</div>
                <div class="choices" id="choices"></div>
            </div>

            <div id="game-over" class="game-over" style="display: none;">
                <h2>Game Over!</h2>
                <p id="result-message"></p>
                <div>
                    <button class="share-btn" onclick="shareResults()">Share Results</button>
                    <button class="new-game-btn" onclick="startNewGame()">Play Again</button>
                </div>
            </div>
        </div>
    </div>

    <div id="copied-toast" class="copied-toast">Results copied to clipboard!</div>
    
    <!-- Level Transition Modal -->
    <div id="level-complete-modal" class="modal">
        <div class="modal-content">
            <h2 id="level-complete-title">üéâ PERFECT! 15/15! üéâ</h2>
            <div id="level-complete-message"></div>
            <button class="new-game-btn" onclick="continueToNextLevel()">Continue</button>
        </div>
    </div>
    
    <!-- Mistake Modal -->
    <div id="mistake-modal" class="modal">
        <div class="modal-content">
            <h2 id="mistake-title">‚ùå Incorrect!</h2>
            <div id="mistake-explanation"></div>
            <button class="new-game-btn" onclick="restartCurrentLevel()">Try Again</button>
        </div>
    </div>

    <div id="help-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">How to Play</h2>
                <button class="close-btn" onclick="closeHelp()">&times;</button>
            </div>
            <div class="modal-body">
                <h3>What is "The Nuts"?</h3>
                <p>In poker, "the nuts" refers to the best possible hand that can be made given the community cards on the board. It's the unbeatable hand at that moment.</p>
                
                <p><strong>IMPORTANT:</strong> The nuts is NOT necessarily the hand YOU have with your hole cards. It's the best hand that ANY player could theoretically have. Your hole cards are shown for reference, but you need to imagine what the best possible hole cards would be!</p>
                
                <h3>How to Identify The Nuts:</h3>
                <ul>
                    <li>Look at all 5 community cards</li>
                    <li>Imagine what 2 hole cards would make the strongest possible hand</li>
                    <li>Ignore YOUR actual hole cards - think theoretically</li>
                    <li>Consider all possibilities: straight flushes, four of a kind, full houses, etc.</li>
                </ul>
                
                <h3>Example:</h3>
                <p>If the board shows: 10‚ô£ 10‚ô† 3‚ô• K‚ô£ 8‚ô•<br>
                The nuts would be Four 10s (if someone has 10‚ô• 10‚ô¶)<br>
                Even if YOU only have a pair of 3s!</p>

                <h3>Hand Rankings (from best to worst):</h3>
                <ol>
                    <li><strong>Royal Flush</strong> - A, K, Q, J, 10 all same suit</li>
                    <li><strong>Straight Flush</strong> - Five cards in sequence, same suit</li>
                    <li><strong>Four of a Kind</strong> - Four cards of same rank</li>
                    <li><strong>Full House</strong> - Three of a kind + pair</li>
                    <li><strong>Flush</strong> - Five cards of same suit</li>
                    <li><strong>Straight</strong> - Five cards in sequence</li>
                    <li><strong>Three of a Kind</strong> - Three cards of same rank</li>
                    <li><strong>Two Pair</strong> - Two different pairs</li>
                    <li><strong>One Pair</strong> - Two cards of same rank</li>
                    <li><strong>High Card</strong> - Highest single card</li>
                </ol>

                <h3>Game Objective:</h3>
                <p>You have 60 seconds or 15 hands (whichever comes first) to correctly identify as many nuts as possible! Each correct answer adds to your score. The game uses seeded randomness based on the current hour (UTC), so everyone playing during the same hour gets the exact same sequence of hands - compete with friends for the high score!</p>
            </div>
        </div>
    </div>

    <script>
        // Wait for pokersolver to load
        window.addEventListener('load', function() {
            if (typeof Hand !== 'undefined') {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('game-content').style.display = 'block';
                initializeGame();
            } else {
                document.getElementById('loading').textContent = 'Error loading poker library. Please refresh the page.';
            }
        });

        // Game state
        let gameStartTime = null;
        let countdownInterval = null;
        let currentAnswer = null;
        let score = 0;
        let gameActive = false;
        let roundActive = false;
        let seedRandom = null;
        let seedCounter = 0;
        let preGeneratedScenarios = [];
        let currentScenarioIndex = 0;
        let totalHandsPlayed = 0;
        const MAX_HANDS = 15;
        
        // Timer pause state (for testing)
        let isPaused = false;
        let pausedElapsedTime = 0;
        let pauseStartTime = null;
        
        // Difficulty progression state
        let currentDifficulty = 'level1'; // 'level1', 'level2', 'level3'
        let streakCount = 0; // Current score/correct answers in this attempt
        let completedLevels = new Set(); // Track completed difficulty levels
        let attemptCounts = { level1: 0, level2: 0, level3: 0 }; // Track attempts per level
        let bestStreaks = { level1: 0, level2: 0, level3: 0 }; // Best streak per difficulty
        
        // Hand will be available globally from pokersolver

        // Card representations
        const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

        class Card {
            constructor(rank, suit) {
                this.rank = rank;
                this.suit = suit;
            }

            isRed() {
                return this.suit === '‚ô•' || this.suit === '‚ô¶';
            }

            // Convert to pokersolver format (e.g., "As", "Td", "7h")
            toPokerSolverString() {
                const rankMap = {
                    '10': 'T',
                    'J': 'J',
                    'Q': 'Q',
                    'K': 'K',
                    'A': 'A'
                };
                const suitMap = {
                    '‚ô†': 's',
                    '‚ô•': 'h',
                    '‚ô¶': 'd',
                    '‚ô£': 'c'
                };
                const psRank = rankMap[this.rank] || this.rank;
                const psSuit = suitMap[this.suit];
                return psRank + psSuit;
            }
        }

        class Deck {
            constructor() {
                this.reset();
            }

            reset() {
                this.cards = [];
                for (let suit of suits) {
                    for (let rank of ranks) {
                        this.cards.push(new Card(rank, suit));
                    }
                }
                this.shuffle();
            }

            shuffle() {
                for (let i = this.cards.length - 1; i > 0; i--) {
                    const j = Math.floor(seededRandom() * (i + 1));
                    [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
                }
            }

            draw(n = 1) {
                const drawn = [];
                for (let i = 0; i < n; i++) {
                    if (this.cards.length > 0) {
                        drawn.push(this.cards.pop());
                    }
                }
                return drawn;
            }
        }

        // Seeded random number generator
        function mulberry32(a) {
            return function() {
                let t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        function seededRandom() {
            if (seedRandom) {
                return seedRandom();
            }
            return Math.random();
        }

        function getDailySeed() {
            // Use current date (UTC) to hour precision for seed
            // This gives everyone the same seed for each hour
            const now = new Date();
            const seed = now.getUTCFullYear() * 10000000 + 
                        (now.getUTCMonth() + 1) * 100000 + 
                        now.getUTCDate() * 1000 + 
                        now.getUTCHours();
            return seed;
        }

        function testPokerSolverUsage() {
            console.log('=== Testing PokerSolver Card Conversion and Comparison ===');
            
            // Test 1: Card conversion
            console.log('\nTest 1: Card Conversion');
            const testCard = new Card('A', '‚ô†');
            console.log('Our card:', testCard.rank, testCard.suit);
            console.log('Converted to pokersolver:', testCard.toPokerSolverString());
            console.log('Expected: As');
            
            // Test 2: Compare two flushes
            console.log('\nTest 2: Comparing Flushes');
            const aceHighFlush = Hand.solve(['Ah', 'Kh', '9h', '5h', '2h']);
            const nineHighFlush = Hand.solve(['9h', '8h', '5h', '3h', '2h']);
            console.log('Ace-high flush:', aceHighFlush.descr);
            console.log('Nine-high flush:', nineHighFlush.descr);
            console.log('aceHighFlush.compare(nineHighFlush):', aceHighFlush.compare(nineHighFlush));
            console.log('nineHighFlush.compare(aceHighFlush):', nineHighFlush.compare(aceHighFlush));
            const flushWinner = Hand.winners([aceHighFlush, nineHighFlush]);
            console.log('Hand.winners() says:', flushWinner[0].descr, 'should win');
            console.log('Expected: Ace-high flush should win');
            
            // Test 3: Compare two four of a kinds
            console.log('\nTest 3: Comparing Four of a Kinds');
            const quadKings = Hand.solve(['Kh', 'Kd', 'Kc', 'Ks', '2h']);
            const quadEights = Hand.solve(['8h', '8d', '8c', '8s', '2h']);
            console.log('Quad Kings:', quadKings.descr);
            console.log('Quad Eights:', quadEights.descr);
            console.log('quadKings.compare(quadEights):', quadKings.compare(quadEights));
            console.log('quadEights.compare(quadKings):', quadEights.compare(quadKings));
            const quadWinner = Hand.winners([quadKings, quadEights]);
            console.log('Hand.winners() says:', quadWinner[0].descr, 'should win');
            console.log('Expected: Quad Kings should win');
        }
        
        function testSpecificBoard() {
            // Run pokersolver tests first
            testPokerSolverUsage();
            console.log('\n=== Testing Specific Boards ===\n');
            // Test a board where we expect certain hands
            // Board: K K 8 8 2 (two pair on board)
            const testBoard = [
                new Card('K', '‚ô†'),
                new Card('K', '‚ô•'),
                new Card('8', '‚ô£'),
                new Card('8', '‚ô¶'),
                new Card('2', '‚ô†')
            ];
            
            console.log('=== Testing specific board: K‚ô† K‚ô• 8‚ô£ 8‚ô¶ 2‚ô† ===');
            
            const boardStrings = cardsToPokerSolverArray(testBoard);
            
            // Test pocket K-K (would make quad Kings)
            const pocketKK = [new Card('K', '‚ô£'), new Card('K', '‚ô¶')];
            const handKK = Hand.solve([...boardStrings, ...cardsToPokerSolverArray(pocketKK)]);
            console.log('With pocket K‚ô£ K‚ô¶:', handKK.descr, 'rank:', handKK.rank);
            
            // Test pocket 8-8 (would make quad 8s)
            const pocket88 = [new Card('8', '‚ô†'), new Card('8', '‚ô•')];
            const hand88 = Hand.solve([...boardStrings, ...cardsToPokerSolverArray(pocket88)]);
            console.log('With pocket 8‚ô† 8‚ô•:', hand88.descr, 'rank:', hand88.rank);
            
            // Compare them
            console.log('Comparing: handKK.compare(hand88) =', handKK.compare(hand88));
            console.log('Comparing: hand88.compare(handKK) =', hand88.compare(handKK));
            console.log('handKK cards:', handKK.cards);
            console.log('hand88 cards:', hand88.cards);
            
            const nuts = findTheNuts(testBoard);
            console.log('\nThe nuts for this board:', nuts.description);
            console.log('Expected: Four of a Kind, Ks (Kings beat 8s)');
            
            // Test another board
            // Board: A A A 5 5 (full house on board itself)
            const testBoard2 = [
                new Card('A', '‚ô†'),
                new Card('A', '‚ô•'),
                new Card('A', '‚ô£'),
                new Card('5', '‚ô¶'),
                new Card('5', '‚ô†')
            ];
            
            console.log('\n=== Testing specific board: A‚ô† A‚ô• A‚ô£ 5‚ô¶ 5‚ô† ===');
            
            const boardStrings2 = cardsToPokerSolverArray(testBoard2);
            
            // Test pocket A-x (would make quad Aces)
            const pocketA = [new Card('A', '‚ô¶'), new Card('7', '‚ô•')];
            const handA = Hand.solve([...boardStrings2, ...cardsToPokerSolverArray(pocketA)]);
            console.log('With pocket A‚ô¶ 7‚ô•:', handA.descr, 'rank:', handA.rank);
            
            // Test pocket 5-5 (would make quad 5s - impossible but let's test)
            const pocket5 = [new Card('5', '‚ô£'), new Card('5', '‚ô•')];
            const hand5 = Hand.solve([...boardStrings2, ...cardsToPokerSolverArray(pocket5)]);
            console.log('With pocket 5‚ô£ 5‚ô•:', hand5.descr, 'rank:', hand5.rank);
            
            // Compare them
            console.log('Comparing: handA.compare(hand5) =', handA.compare(hand5));
            console.log('Comparing: hand5.compare(handA) =', hand5.compare(handA));
            
            const nuts2 = findTheNuts(testBoard2);
            console.log('\nThe nuts for this board:', nuts2.description);
            console.log('Expected: Four of a Kind, As (Aces beat 5s)');
            
            // Test a board with single pair where Full House should be nuts
            // Board: Q Q 7 3 2 rainbow
            const testBoard3 = [
                new Card('Q', '‚ô†'),
                new Card('Q', '‚ô•'),
                new Card('7', '‚ô£'),
                new Card('3', '‚ô¶'),
                new Card('2', '‚ô†')
            ];
            
            console.log('\n=== Testing specific board: Q‚ô† Q‚ô• 7‚ô£ 3‚ô¶ 2‚ô† ===');
            const nuts3 = findTheNuts(testBoard3);
            console.log('The nuts for this board:', nuts3.description);
            console.log('Expected: Four of a Kind (Quad Queens)');
            
            // Test a board where Full House IS the nuts
            // Board with trips: 9 9 9 K 2 (no quads possible)
            const testBoard4 = [
                new Card('9', '‚ô†'),
                new Card('9', '‚ô•'),
                new Card('9', '‚ô£'),
                new Card('K', '‚ô¶'),
                new Card('2', '‚ô†')
            ];
            
            console.log('\n=== Testing specific board: 9‚ô† 9‚ô• 9‚ô£ K‚ô¶ 2‚ô† ===');
            const nuts4 = findTheNuts(testBoard4);
            console.log('The nuts for this board:', nuts4.description);
            console.log('Expected: Four of a Kind, 9s (pocket 9-x makes quad nines)');
            
            // Test a board where the board itself is a full house
            // Board: 7 7 7 3 3 - Best would be quad 7s or quad 3s
            const testBoard5 = [
                new Card('7', '‚ô†'),
                new Card('7', '‚ô•'),
                new Card('7', '‚ô£'),
                new Card('3', '‚ô¶'),
                new Card('3', '‚ô†')
            ];
            
            console.log('\n=== Testing specific board: 7‚ô† 7‚ô• 7‚ô£ 3‚ô¶ 3‚ô† ===');
            const nuts5 = findTheNuts(testBoard5);
            console.log('The nuts for this board:', nuts5.description);
            console.log('Expected: Four of a Kind, 7s (pocket 7-x makes quad sevens)');
            
            console.log('\n=== CONCLUSION ===');
            console.log('Full House can never be the nuts because:');
            console.log('- If there\'s a pair on board, pocket pair makes quads');
            console.log('- If there are trips on board, the 4th card makes quads');
            console.log('- If board has full house, pocket card can make quads');
            console.log('This explains why we see 0% Full House in generation!');
            
            // Test if two pair can ever be the nuts
            // First test: 2-3-7-8-A
            const testBoard6 = [
                new Card('2', '‚ô†'),
                new Card('3', '‚ô•'),
                new Card('7', '‚ô£'),
                new Card('8', '‚ô¶'),
                new Card('A', '‚ô†')
            ];
            
            console.log('\n=== Testing: 2‚ô† 3‚ô• 7‚ô£ 8‚ô¶ A‚ô† ===');
            const nuts6 = findTheNuts(testBoard6);
            console.log('The nuts for this board:', nuts6.description);
            console.log('Expected: Straight (4-5 makes wheel A-2-3-4-5) or Trips if no straight');
            
            // Test with maximum gaps to prevent straights - avoid Ace!
            // 2-4-7-J-K has no possible straights
            const testBoard7 = [
                new Card('2', '‚ô†'),
                new Card('4', '‚ô•'),
                new Card('7', '‚ô£'),
                new Card('J', '‚ô¶'),
                new Card('K', '‚ô£')
            ];
            
            console.log('\n=== Testing maximum gaps (no Ace): 2‚ô† 4‚ô• 7‚ô£ J‚ô¶ K‚ô£ ===');
            const nuts7 = findTheNuts(testBoard7);
            console.log('The nuts for this board:', nuts7.description);
            console.log('Analysis: No straight possible (no 5-card sequence). Should be Three of a Kind!');
            console.log('\nConclusion: Even without straights, pocket pairs make trips which beat two pair.');
            console.log('Therefore, Two Pair can NEVER be the nuts!');
        }
        
        function initializeGame() {
            // Hand is already available as a global from pokersolver
            document.querySelector('.new-game-btn').onclick = startNewGame;
            
            // Run test first (disabled for production)
            // testSpecificBoard();
            
            // Initialize first attempt count
            attemptCounts[currentDifficulty] = 1;
            
            // Reset pause state
            isPaused = false;
            pausedElapsedTime = 0;
            pauseStartTime = null;
            
            startNewGame();
        }

        // Convert cards array to pokersolver format
        function cardsToPokerSolverArray(cards) {
            return cards.map(card => card.toPokerSolverString());
        }

        // Format pokersolver hand description for display
        function formatHandDescription(description) {
            // pokersolver returns descriptions like "Four of a Kind, A's"
            // We'll clean these up for consistent display
            // Just remove apostrophes, pokersolver already formats nicely
            return description.replace(/'/g, '');
        }

        // Find the absolute nuts using pokersolver
        function findTheNuts(communityCards) {
            const communityStrings = cardsToPokerSolverArray(communityCards);
            
            // Generate all remaining cards not on the board
            const remainingCards = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    const card = new Card(rank, suit);
                    if (!communityCards.some(cc => cc.rank === card.rank && cc.suit === card.suit)) {
                        remainingCards.push(card);
                    }
                }
            }
            
            let bestHand = null;
            let bestRank = -1;
            let bestHoleCards = null;
            
            // Check all possible hole card combinations
            for (let i = 0; i < remainingCards.length - 1; i++) {
                for (let j = i + 1; j < remainingCards.length; j++) {
                    const holeCards = [remainingCards[i], remainingCards[j]];
                    const allCardStrings = [
                        ...communityStrings,
                        ...cardsToPokerSolverArray(holeCards)
                    ];
                    
                    // PokerSolver.Hand.solve automatically finds the best 5-card hand from 7 cards
                    const hand = Hand.solve(allCardStrings);
                    
                    // Use Hand.winners() to properly compare hands
                    // This handles all tie-breaker logic correctly
                    if (!bestHand) {
                        bestHand = hand;
                        bestRank = hand.rank;
                        bestHoleCards = holeCards;
                    } else {
                        // Let pokersolver determine the winner using Hand.winners()
                        const winners = Hand.winners([bestHand, hand]);
                        if (winners[0] === hand) {
                            bestHand = hand;
                            bestRank = hand.rank;
                            bestHoleCards = holeCards;
                        }
                        // If winners[0] === bestHand, keep current best
                    }
                }
            }
            
            return {
                description: formatHandDescription(bestHand.descr),
                holeCards: bestHoleCards
            };
        }

        // Find player's best hand
        function findPlayerBestHand(communityCards, holeCards) {
            const allCardStrings = [
                ...cardsToPokerSolverArray(communityCards),
                ...cardsToPokerSolverArray(holeCards)
            ];
            
            const hand = Hand.solve(allCardStrings);
            return formatHandDescription(hand.descr);
        }

        // Generate possible hands for wrong answers with strategic decoys
        function generatePossibleHands(communityCards) {
            const possibleHands = [];
            const usedDescriptions = new Set();
            const deck = new Deck();
            
            // Remove community cards from deck
            deck.cards = deck.cards.filter(card => 
                !communityCards.some(cc => cc.rank === card.rank && cc.suit === card.suit)
            );
            
            // Analyze board for strategic decoy generation
            const boardAnalysis = analyzeBoardTexture(communityCards);
            
            // 1. Generate strong strategic decoys based on board texture
            const strategicDecoys = generateStrategicDecoys(communityCards, deck, boardAnalysis);
            for (let decoy of strategicDecoys) {
                if (!usedDescriptions.has(decoy.description)) {
                    possibleHands.push(decoy);
                    usedDescriptions.add(decoy.description);
                }
            }
            
            // 2. Sample additional random combinations for variety
            for (let attempt = 0; attempt < 20; attempt++) {
                const i = Math.floor(seededRandom() * deck.cards.length);
                let j = Math.floor(seededRandom() * deck.cards.length);
                while (j === i) {
                    j = Math.floor(seededRandom() * deck.cards.length);
                }
                
                const sampleHoleCards = [deck.cards[i], deck.cards[j]];
                const allCardStrings = [
                    ...cardsToPokerSolverArray(communityCards),
                    ...cardsToPokerSolverArray(sampleHoleCards)
                ];
                
                const hand = Hand.solve(allCardStrings);
                const description = formatHandDescription(hand.descr);
                
                if (!usedDescriptions.has(description)) {
                    possibleHands.push({
                        description: description,
                        holeCards: sampleHoleCards,
                        rank: hand.rank
                    });
                    usedDescriptions.add(description);
                }
            }
            
            return possibleHands;
        }
        
        // Analyze board texture for strategic decoy generation
        function analyzeBoardTexture(communityCards) {
            const suits = {};
            const ranks = {};
            const sortedRanks = [];
            
            // Count suits and ranks
            communityCards.forEach(card => {
                suits[card.suit] = (suits[card.suit] || 0) + 1;
                ranks[card.rank] = (ranks[card.rank] || 0) + 1;
                sortedRanks.push(card.rank);
            });
            
            // Check for flush possibilities
            const flushSuit = Object.keys(suits).find(suit => suits[suit] >= 3);
            const hasFlushDraw = flushSuit !== undefined;
            const isFlushOnBoard = Object.values(suits).some(count => count >= 5);
            
            // Check for straight possibilities
            const rankValues = sortedRanks.map(r => "23456789TJQKA".indexOf(r));
            rankValues.sort((a, b) => a - b);
            const hasStraightDraw = checkStraightPossibility(rankValues);
            
            // Check for paired board
            const hasPair = Object.values(ranks).some(count => count === 2);
            const hasTrips = Object.values(ranks).some(count => count === 3);
            const hasQuads = Object.values(ranks).some(count => count === 4);
            
            return {
                flushSuit,
                hasFlushDraw,
                isFlushOnBoard,
                hasStraightDraw,
                hasPair,
                hasTrips,
                hasQuads,
                ranks,
                suits
            };
        }
        
        // Check if straight is possible with the board
        function checkStraightPossibility(sortedRankValues) {
            // Check for possible 5-card sequences including potential hole cards
            for (let i = 0; i <= sortedRankValues.length - 3; i++) {
                const gap = sortedRankValues[i + 2] - sortedRankValues[i];
                if (gap <= 4) return true; // Straight possible with right hole cards
            }
            return false;
        }
        
        // Generate strategic decoys based on board analysis
        function generateStrategicDecoys(communityCards, deck, analysis) {
            const decoys = [];
            
            // 1. If flush is possible, generate second-nut flush
            if (analysis.hasFlushDraw && analysis.flushSuit) {
                const suitedCards = deck.cards.filter(c => c.suit === analysis.flushSuit);
                if (suitedCards.length >= 2) {
                    // Get high cards but not the highest for second-nut flush
                    suitedCards.sort((a, b) => "23456789TJQKA".indexOf(b.rank) - "23456789TJQKA".indexOf(a.rank));
                    if (suitedCards.length > 2) {
                        // Skip the ace if available to make second-nut flush
                        const startIdx = suitedCards[0].rank === 'A' ? 1 : 0;
                        if (startIdx + 1 < suitedCards.length) {
                            const flushHoleCards = [suitedCards[startIdx], suitedCards[startIdx + 1]];
                            const allCardStrings = [
                                ...cardsToPokerSolverArray(communityCards),
                                ...cardsToPokerSolverArray(flushHoleCards)
                            ];
                            const hand = Hand.solve(allCardStrings);
                            decoys.push({
                                description: formatHandDescription(hand.descr),
                                holeCards: flushHoleCards,
                                rank: hand.rank
                            });
                        }
                    }
                }
            }
            
            // 2. If board is paired, generate trips or full house
            if (analysis.hasPair) {
                const pairedRank = Object.keys(analysis.ranks).find(r => analysis.ranks[r] === 2);
                const matchingCard = deck.cards.find(c => c.rank === pairedRank);
                if (matchingCard) {
                    // Find another high card for trips
                    const otherCard = deck.cards.find(c => c !== matchingCard && "AKQJ".includes(c.rank));
                    if (otherCard) {
                        const tripsHoleCards = [matchingCard, otherCard];
                        const allCardStrings = [
                            ...cardsToPokerSolverArray(communityCards),
                            ...cardsToPokerSolverArray(tripsHoleCards)
                        ];
                        const hand = Hand.solve(allCardStrings);
                        decoys.push({
                            description: formatHandDescription(hand.descr),
                            holeCards: tripsHoleCards,
                            rank: hand.rank
                        });
                    }
                }
            }
            
            // 3. Generate high pocket pairs for overpairs/sets
            const highRanks = ['A', 'K', 'Q', 'J'];
            for (let rank of highRanks) {
                const pairCards = deck.cards.filter(c => c.rank === rank);
                if (pairCards.length >= 2) {
                    const pocketPair = [pairCards[0], pairCards[1]];
                    const allCardStrings = [
                        ...cardsToPokerSolverArray(communityCards),
                        ...cardsToPokerSolverArray(pocketPair)
                    ];
                    const hand = Hand.solve(allCardStrings);
                    decoys.push({
                        description: formatHandDescription(hand.descr),
                        holeCards: pocketPair,
                        rank: hand.rank
                    });
                    break; // Only one pocket pair decoy
                }
            }
            
            // 4. Generate two high cards for potential straights or high pairs
            const aceCard = deck.cards.find(c => c.rank === 'A');
            const kingCard = deck.cards.find(c => c.rank === 'K');
            if (aceCard && kingCard && aceCard.suit !== kingCard.suit) {
                const bigSlick = [aceCard, kingCard];
                const allCardStrings = [
                    ...cardsToPokerSolverArray(communityCards),
                    ...cardsToPokerSolverArray(bigSlick)
                ];
                const hand = Hand.solve(allCardStrings);
                decoys.push({
                    description: formatHandDescription(hand.descr),
                    holeCards: bigSlick,
                    rank: hand.rank
                });
            }
            
            return decoys;
        }
        
        // Generate hint text for Easy mode
        function generateHintText(handDescription) {
            // Extract the hand type from the description
            if (handDescription.includes('Royal Flush')) return '(Makes: Royal Flush!)';
            if (handDescription.includes('Straight Flush')) return '(Makes: Straight Flush!)';
            if (handDescription.includes('Four of a Kind')) return '(Makes: Four of a Kind)';
            if (handDescription.includes('Full House')) return '(Makes: Full House)';
            if (handDescription.includes('Flush')) return '(Makes: Flush)';
            if (handDescription.includes('Straight')) return '(Makes: Straight)';
            if (handDescription.includes('Three of a Kind')) return '(Makes: Three of a Kind)';
            if (handDescription.includes('Two Pair')) return '(Makes: Two Pair)';
            if (handDescription.includes('Pair')) return '(Makes: One Pair)';
            if (handDescription.includes('High Card')) return '(Makes: High Card)';
            // Fallback - parse the hand type from description
            const match = handDescription.match(/^([^,]+)/);
            return match ? `(Makes: ${match[1]})` : '(Makes: This Hand)';
        }
        
        // Difficulty-specific scenario generation
        function generateLevel1Scenario() {
            const deck = new Deck();
            const communityCards = deck.draw(5);
            const theNuts = findTheNuts(communityCards);
            
            // Generate choices with wide strength gaps
            const choices = [];
            const usedRanks = new Set();
            
            // Add the nuts with its hint
            theNuts.hint = generateHintText(theNuts.description);
            choices.push(theNuts);
            usedRanks.add(theNuts.rank);
            
            // Add weak decoys for easy mode
            const remainingDeck = deck.cards.filter(card => 
                !communityCards.some(cc => cc.rank === card.rank && cc.suit === card.suit)
            );
            
            // Try to add hands that are 3+ ranks apart
            let attempts = 0;
            while (choices.length < 4 && attempts < 50) {
                attempts++;
                const i = Math.floor(seededRandom() * remainingDeck.length);
                let j = Math.floor(seededRandom() * remainingDeck.length);
                while (j === i) {
                    j = Math.floor(seededRandom() * remainingDeck.length);
                }
                
                const holeCards = [remainingDeck[i], remainingDeck[j]];
                const allCardStrings = [
                    ...cardsToPokerSolverArray(communityCards),
                    ...cardsToPokerSolverArray(holeCards)
                ];
                const hand = Hand.solve(allCardStrings);
                
                // Only add if rank difference is significant
                const rankDiff = Math.abs(theNuts.rank - hand.rank);
                if (rankDiff >= 3 || choices.length === 3) { // Accept any for last choice
                    choices.push({
                        description: formatHandDescription(hand.descr),
                        holeCards: holeCards,
                        rank: hand.rank,
                        hint: generateHintText(formatHandDescription(hand.descr)) // Generate hint based on THIS hand
                    });
                }
            }
            
            // Ensure we have 4 choices
            while (choices.length < 4) {
                const i = Math.floor(seededRandom() * remainingDeck.length);
                const j = (i + 1) % remainingDeck.length;
                const holeCards = [remainingDeck[i], remainingDeck[j]];
                const allCardStrings = [
                    ...cardsToPokerSolverArray(communityCards),
                    ...cardsToPokerSolverArray(holeCards)
                ];
                const hand = Hand.solve(allCardStrings);
                choices.push({
                    description: formatHandDescription(hand.descr),
                    holeCards: holeCards,
                    rank: hand.rank,
                    hint: generateHintText(formatHandDescription(hand.descr))
                });
            }
            
            const choicesArray = choices.slice(0, 4);
            
            // Shuffle choices
            for (let i = choicesArray.length - 1; i > 0; i--) {
                const j = Math.floor(seededRandom() * (i + 1));
                [choicesArray[i], choicesArray[j]] = [choicesArray[j], choicesArray[i]];
            }
            
            return {
                communityCards,
                choices: choicesArray,
                answer: theNuts,
                difficulty: 'level1'
            };
        }
        
        function generateLevel2Scenario() {
            // Use current generateScenario logic for level 2
            const scenario = generateScenario();
            scenario.difficulty = 'level2';
            return scenario;
        }
        
        function generateLevel3Scenario() {
            const deck = new Deck();
            const communityCards = deck.draw(5);
            const theNuts = findTheNuts(communityCards);
            
            // Generate choices with very close strength (within 1-2 ranks)
            const choices = [];
            choices.push(theNuts);
            
            // Analyze board for strategic hard mode decoys
            const boardAnalysis = analyzeBoardTexture(communityCards);
            
            // Always try to include the exact second-best hand
            const remainingDeck = deck.cards.filter(card => 
                !communityCards.some(cc => cc.rank === card.rank && cc.suit === card.suit)
            );
            
            // Find hands very close in strength
            const nearNutsHands = [];
            for (let i = 0; i < remainingDeck.length - 1; i++) {
                for (let j = i + 1; j < remainingDeck.length; j++) {
                    const holeCards = [remainingDeck[i], remainingDeck[j]];
                    const allCardStrings = [
                        ...cardsToPokerSolverArray(communityCards),
                        ...cardsToPokerSolverArray(holeCards)
                    ];
                    const hand = Hand.solve(allCardStrings);
                    
                    // Only consider hands within 2 ranks of nuts
                    if (Math.abs(hand.rank - theNuts.rank) <= 2 && hand.rank !== theNuts.rank) {
                        nearNutsHands.push({
                            description: formatHandDescription(hand.descr),
                            holeCards: holeCards,
                            rank: hand.rank
                        });
                    }
                }
            }
            
            // Sort by rank and take the closest ones
            nearNutsHands.sort((a, b) => b.rank - a.rank);
            
            // Add the top 3 closest hands
            for (let i = 0; i < Math.min(3, nearNutsHands.length); i++) {
                choices.push(nearNutsHands[i]);
            }
            
            // Ensure we have 4 choices
            while (choices.length < 4) {
                const i = Math.floor(seededRandom() * remainingDeck.length);
                const j = (i + 1) % remainingDeck.length;
                const holeCards = [remainingDeck[i], remainingDeck[j]];
                const allCardStrings = [
                    ...cardsToPokerSolverArray(communityCards),
                    ...cardsToPokerSolverArray(holeCards)
                ];
                const hand = Hand.solve(allCardStrings);
                choices.push({
                    description: formatHandDescription(hand.descr),
                    holeCards: holeCards,
                    rank: hand.rank
                });
            }
            
            const choicesArray = choices.slice(0, 4);
            
            // Shuffle choices
            for (let i = choicesArray.length - 1; i > 0; i--) {
                const j = Math.floor(seededRandom() * (i + 1));
                [choicesArray[i], choicesArray[j]] = [choicesArray[j], choicesArray[i]];
            }
            
            return {
                communityCards,
                choices: choicesArray,
                answer: theNuts,
                difficulty: 'level3'
            };
        }

        function generateScenario() {
            const deck = new Deck();
            const communityCards = deck.draw(5);
            
            // Find the absolute nuts
            const theNuts = findTheNuts(communityCards);
            
            // Debug: Don't log anything for now to reduce noise
            
            // Generate choices
            const choices = [];
            const usedDescriptions = new Set();
            
            // Add the nuts as first choice
            choices.push(theNuts);
            usedDescriptions.add(theNuts.description);
            
            // Generate other possible hands, prioritizing diverse hand types
            const possibleHands = generatePossibleHands(communityCards);
            
            // Sort by rank to get a variety of hand strengths
            possibleHands.sort((a, b) => b.rank - a.rank);
            
            for (let hand of possibleHands) {
                if (choices.length >= 4) break;
                // Avoid duplicate hand descriptions
                if (!usedDescriptions.has(hand.description)) {
                    choices.push(hand);
                    usedDescriptions.add(hand.description);
                }
            }
            
            // If we still need more choices, generate board play with random hole cards
            let fallbackAttempts = 0;
            const MAX_FALLBACK_ATTEMPTS = 50;
            while (choices.length < 4 && fallbackAttempts < MAX_FALLBACK_ATTEMPTS) {
                fallbackAttempts++;
                const remainingDeck = deck.cards.filter(card => 
                    !communityCards.some(cc => cc.rank === card.rank && cc.suit === card.suit)
                );
                
                if (remainingDeck.length < 2) break; // Not enough cards left
                
                const i = Math.floor(seededRandom() * remainingDeck.length);
                let j = Math.floor(seededRandom() * remainingDeck.length);
                let innerAttempts = 0;
                while (j === i && innerAttempts < 10) {
                    j = Math.floor(seededRandom() * remainingDeck.length);
                    innerAttempts++;
                }
                if (j === i && remainingDeck.length > 1) {
                    j = (i + 1) % remainingDeck.length; // Fallback to next card
                }
                const randomHoleCards = [remainingDeck[i], remainingDeck[j]];
                const allCardStrings = [
                    ...cardsToPokerSolverArray(communityCards),
                    ...cardsToPokerSolverArray(randomHoleCards)
                ];
                const hand = Hand.solve(allCardStrings);
                const desc = formatHandDescription(hand.descr);
                
                // If we can't find unique descriptions, accept duplicates to avoid infinite loop
                if (!usedDescriptions.has(desc) || fallbackAttempts > MAX_FALLBACK_ATTEMPTS - 10) {
                    choices.push({
                        description: desc,
                        holeCards: randomHoleCards,
                        rank: hand.rank
                    });
                    usedDescriptions.add(desc);
                }
            }
            
            // Ensure we have exactly 4 choices
            const choicesArray = choices.slice(0, 4);
            
            // Shuffle choices
            for (let i = choicesArray.length - 1; i > 0; i--) {
                const j = Math.floor(seededRandom() * (i + 1));
                [choicesArray[i], choicesArray[j]] = [choicesArray[j], choicesArray[i]];
            }
            
            return {
                communityCards,
                choices: choicesArray,
                answer: theNuts
            };
        }

        function renderCard(card, container) {
            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${card.isRed() ? 'red' : 'black'}`;
            cardDiv.innerHTML = `
                <div class="card-rank">${card.rank}</div>
                <div class="card-suit">${card.suit}</div>
            `;
            container.appendChild(cardDiv);
        }

        function renderCards(cards, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            cards.forEach(card => renderCard(card, container));
        }

        function formatHandForDisplay(handDescription) {
            // Convert card notation to symbols
            // Only replace when it's actually a card notation (capital letter followed by lowercase suit)
            // Use word boundaries to avoid replacing in the middle of words
            let formatted = handDescription
                // Replace card notations with colored spans - must be preceded by space, comma, or start of string
                .replace(/(^|[, ])([2-9TJQKA]|10)s\b/g, '$1<span class="card-spade">$2‚ô†</span>')  // Spades
                .replace(/(^|[, ])([2-9TJQKA]|10)h\b/g, '$1<span class="card-heart">$2‚ô•</span>')  // Hearts  
                .replace(/(^|[, ])([2-9TJQKA]|10)d\b/g, '$1<span class="card-diamond">$2‚ô¶</span>')  // Diamonds
                .replace(/(^|[, ])([2-9TJQKA]|10)c\b/g, '$1<span class="card-club">$2‚ô£</span>')  // Clubs
                // Handle "High" format (e.g., "Ah High")
                .replace(/\b([2-9TJQKA])h High/g, '<span class="card-heart">$1‚ô•</span> High')  // Hearts in "High" context
                .replace(/\b([2-9TJQKA])s High/g, '<span class="card-spade">$1‚ô†</span> High')  // Spades in "High" context
                .replace(/\b([2-9TJQKA])d High/g, '<span class="card-diamond">$1‚ô¶</span> High')  // Diamonds in "High" context
                .replace(/\b([2-9TJQKA])c High/g, '<span class="card-club">$1‚ô£</span> High');  // Clubs in "High" context
            
            // Replace T with 10 only when it's a card (now within the spans)
            formatted = formatted.replace(/>T([‚ô†‚ô•‚ô¶‚ô£])</g, '>10$1<');
            
            // Handle apostrophes in descriptions like "K's" -> "Ks"
            formatted = formatted.replace(/([2-9TJQKA10])['']s\b/g, '$1s');
            
            return formatted;
        }
        
        function formatHoleCardsForDisplay(holeCards) {
            // Format hole cards for display with colored suits
            const card1 = holeCards[0];
            const card2 = holeCards[1];
            
            function formatCard(card) {
                const rank = card.rank === 'T' ? '10' : card.rank;
                const suitClass = (card.suit === '‚ô•' || card.suit === '‚ô¶') ? 
                    (card.suit === '‚ô•' ? 'card-heart' : 'card-diamond') : 
                    (card.suit === '‚ô†' ? 'card-spade' : 'card-club');
                return `<span class="${suitClass}">${rank}${card.suit}</span>`;
            }
            
            return `${formatCard(card1)} ${formatCard(card2)}`;
        }
        
        function renderChoices(choices) {
            const container = document.getElementById('choices');
            container.innerHTML = '';
            
            choices.forEach(choice => {
                const button = document.createElement('button');
                button.className = 'choice-btn';
                
                // Display hole cards
                let buttonHTML = formatHoleCardsForDisplay(choice.holeCards);
                
                // Add hint text for level 1
                if (currentDifficulty === 'level1' && choice.hint) {
                    buttonHTML += `<div class="hint-text">${choice.hint}</div>`;
                }
                
                button.innerHTML = buttonHTML;
                button.dataset.answer = JSON.stringify(choice); // Store full choice object
                button.onclick = (e) => {
                    e.preventDefault();
                    e.target.blur(); // Immediately blur on click
                    selectAnswer(choice);
                };
                container.appendChild(button);
            });
        }

        function startCountdown() {
            gameStartTime = Date.now();
            countdownInterval = setInterval(updateCountdown, 100);
        }

        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
        }

        function getLevelDisplayName() {
            if (currentDifficulty === 'level1') return 'Level 1';
            if (currentDifficulty === 'level2') return 'Level 2';
            if (currentDifficulty === 'level3') return 'Level 3';
            return 'Level 1';
        }
        
        function updateCountdown() {
            if (gameStartTime && !isPaused) {
                const elapsed = ((Date.now() - gameStartTime) / 1000) + pausedElapsedTime;
                // Different timer for level 3 (30s instead of 60s)
                const maxTime = currentDifficulty === 'level3' ? 30 : 60;
                const remaining = Math.max(0, maxTime - elapsed);
                const pauseIndicator = isPaused ? ' ‚è∏' : '';
                const levelName = getLevelDisplayName();
                document.getElementById('countdown').textContent = `${levelName} ‚Ä¢ ${remaining.toFixed(1)}s${pauseIndicator}`;
                
                if (remaining <= 0) {
                    // Safeguard: Don't process timeout if game already ended
                    if (!gameActive || totalHandsPlayed >= MAX_HANDS) return;
                    // Time out counts as a mistake
                    handleMistake({ description: 'Time Out', holeCards: [] }, currentAnswer);
                }
            } else if (isPaused) {
                // Update display to show paused state
                const elapsed = ((pauseStartTime - gameStartTime) / 1000) + pausedElapsedTime;
                const maxTime = currentDifficulty === 'level3' ? 30 : 60;
                const remaining = Math.max(0, maxTime - elapsed);
                const levelName = getLevelDisplayName();
                document.getElementById('countdown').textContent = `${levelName} ‚Ä¢ ${remaining.toFixed(1)}s ‚è∏`;
            }
        }
        
        function togglePause() {
            if (!gameActive) return; // Only allow pause during active game
            
            const countdownEl = document.getElementById('countdown');
            
            if (isPaused) {
                // Unpause
                isPaused = false;
                // Calculate how long we were paused and add to pausedElapsedTime
                pausedElapsedTime += (Date.now() - pauseStartTime) / 1000;
                // Reset game start time to account for the pause
                gameStartTime = Date.now() - (pauseStartTime - gameStartTime);
                pauseStartTime = null;
                countdownEl.classList.remove('paused');
            } else {
                // Pause
                isPaused = true;
                pauseStartTime = Date.now();
                countdownEl.classList.add('paused');
            }
            
            // Update display immediately
            updateCountdown();
        }

        function selectAnswer(choice) {
            if (!roundActive || !gameActive) return;
            
            roundActive = false;
            
            const isCorrect = choice.description === currentAnswer.description;
            
            const buttons = document.querySelectorAll('.choice-btn');
            buttons.forEach(btn => {
                btn.disabled = true;
                // Remove focus from button to prevent sticky highlighting on mobile
                btn.blur();
                const btnChoice = JSON.parse(btn.dataset.answer);
                
                // Add hand description as feedback
                const originalHTML = btn.innerHTML;
                btn.innerHTML = `${originalHTML}<br><small style="font-size: 12px; opacity: 0.9">${formatHandForDisplay(btnChoice.description)}</small>`;
                
                // Compare by description since that uniquely identifies the hand strength
                if (btnChoice.description === currentAnswer.description) {
                    btn.classList.add('correct');
                } else if (btnChoice.description === choice.description && choice.description !== currentAnswer.description) {
                    btn.classList.add('incorrect');
                }
            });
            
            if (isCorrect) {
                // Correct answer - increment score
                streakCount++;
                score++;
                document.getElementById('score').textContent = score;
            }
            
            // Always continue playing all 15 hands regardless of mistakes
            totalHandsPlayed++;
            
            // Update progress dots - pass whether this answer was correct
            updateProgressDots(isCorrect);
            
            if (totalHandsPlayed >= MAX_HANDS) {
                // Stop timer immediately to prevent race condition
                stopCountdown();
                gameActive = false;
                // Completed all 15 hands - check if perfect
                setTimeout(() => {
                    if (streakCount >= MAX_HANDS) {
                        handleLevelComplete();
                    } else {
                        handleLevelFailure();
                    }
                }, 1500);
            } else {
                // Continue to next round
                setTimeout(() => {
                    if (gameActive) {
                        nextRound();
                    }
                }, 1000);
            }
        }

        function getHandTypeCategory(handDescription) {
            // Extract the base hand type from descriptions like "Four of a Kind, As"
            if (handDescription.includes('Royal Flush')) return 'Royal Flush';
            if (handDescription.includes('Straight Flush')) return 'Straight Flush';
            if (handDescription.includes('Four of a Kind')) return 'Four of a Kind';
            if (handDescription.includes('Full House')) return 'Full House';
            if (handDescription.includes('Flush')) return 'Flush';
            if (handDescription.includes('Straight')) return 'Straight';
            if (handDescription.includes('Three of a Kind')) return 'Three of a Kind';
            if (handDescription.includes('Two Pair')) return 'Two Pair';
            // Note: Pair and High Card should never appear as the nuts
            if (handDescription.includes('Pair')) return 'Pair';
            return 'High Card';
        }

        function preGenerateScenarios(count) {
            preGeneratedScenarios = [];
            const handTypeCounts = {};  // Tracks accepted scenarios
            const generatedTypeCounts = {};  // Tracks ALL generated scenarios
            const MAX_PER_TYPE = 3;  // Changed from 2 to 3 since only 6 hand types are possible as nuts
            let attempts = 0;
            const MAX_ATTEMPTS = count * 100; // More attempts for better variety
            let rejectCount = 0;
            const rejectedTypes = {}; // Track rejections by type
            
            // console.log('Starting scenario generation for', count, 'hands');
            
            while (preGeneratedScenarios.length < count && attempts < MAX_ATTEMPTS) {
                attempts++;
                // Generate scenario based on current difficulty
                let scenario;
                if (currentDifficulty === 'level1') {
                    scenario = generateLevel1Scenario();
                } else if (currentDifficulty === 'level2') {
                    scenario = generateLevel2Scenario();
                } else {
                    scenario = generateLevel3Scenario();
                }
                const handType = getHandTypeCategory(scenario.answer.description);
                
                // Track ALL generated types
                if (!generatedTypeCounts[handType]) {
                    generatedTypeCounts[handType] = 0;
                }
                generatedTypeCounts[handType]++;
                
                // Initialize accepted counter if needed
                if (!handTypeCounts[handType]) {
                    handTypeCounts[handType] = 0;
                }
                
                if (handTypeCounts[handType] < MAX_PER_TYPE) {
                    handTypeCounts[handType]++;
                    preGeneratedScenarios.push(scenario);
                    // Removed individual logging to reduce clutter
                } else {
                    // Track rejections silently
                    rejectCount++;
                    if (!rejectedTypes[handType]) {
                        rejectedTypes[handType] = 0;
                    }
                    rejectedTypes[handType]++;
                    
                    // Only log every 100 rejections to reduce spam
                    if (rejectCount % 100 === 0) {
                        console.log(`Progress: ${rejectCount} rejections, ${preGeneratedScenarios.length}/${count} scenarios found`);
                    }
                }
            }
            
            // Only fill remaining if we really couldn't generate enough variety
            if (preGeneratedScenarios.length < count) {
                console.warn(`Could only generate ${preGeneratedScenarios.length}/${count} scenarios with variety limits.`);
                console.warn(`Filling remaining slots - variety limits will be exceeded.`);
                
                // Just fill the remaining slots
                while (preGeneratedScenarios.length < count) {
                    const scenario = generateScenario();
                    const handType = getHandTypeCategory(scenario.answer);
                    
                    if (!handTypeCounts[handType]) {
                        handTypeCounts[handType] = 0;
                    }
                    handTypeCounts[handType]++;
                    
                    if (!generatedTypeCounts[handType]) {
                        generatedTypeCounts[handType] = 0;
                    }
                    generatedTypeCounts[handType]++;
                    
                    preGeneratedScenarios.push(scenario);
                    console.log(`Overflow: Added ${handType} (now at ${handTypeCounts[handType]} total)`);
                }
            }
            
            // Log final summary
            console.log('=== Generation Summary ===');
            console.log('Accepted distribution:', handTypeCounts);
            console.log(`Total: ${preGeneratedScenarios.length} scenarios from ${attempts} attempts (${rejectCount} rejected)`);
            
            // Show which types were rejected most
            if (Object.keys(rejectedTypes).length > 0) {
                console.log('Rejected by type:', rejectedTypes);
            }
            
            // Create comprehensive generation report
            console.log('\n=== Generation Report ===');
            console.log(`Total Generated: ${attempts}`);
            
            // All possible hand types that can actually be the nuts
            // (Pair and High Card can never be the nuts)
            const allHandTypes = [
                'Royal Flush', 'Straight Flush', 'Four of a Kind',
                'Full House', 'Flush', 'Straight',
                'Three of a Kind', 'Two Pair'
            ];
            
            // Sort by count (descending)
            const sortedTypes = allHandTypes.map(type => ({
                type: type,
                count: generatedTypeCounts[type] || 0,
                percentage: ((generatedTypeCounts[type] || 0) / attempts * 100).toFixed(1)
            })).sort((a, b) => b.count - a.count);
            
            console.log('\nBreakdown by hand type:');
            sortedTypes.forEach(item => {
                const bar = '‚ñà'.repeat(Math.floor(item.percentage / 2)); // Visual bar
                console.log(`${item.count.toString().padStart(4)} ${item.type.padEnd(20)} ${item.percentage.padStart(5)}% ${bar}`);
            });
            
            // Show acceptance rate
            console.log('\n=== Acceptance Rates ===');
            allHandTypes.forEach(type => {
                const generated = generatedTypeCounts[type] || 0;
                const accepted = handTypeCounts[type] || 0;
                if (generated > 0) {
                    const acceptRate = (accepted / generated * 100).toFixed(1);
                    console.log(`${type.padEnd(20)}: ${accepted}/${generated} accepted (${acceptRate}%)`);
                }
            });
        }

        // Handle level failure (didn't get 15/15)
        function handleLevelFailure() {
            gameActive = false;
            currentAnswer = null; // Clear stale data
            
            // Update personal best if current is better
            if (streakCount > bestStreaks[currentDifficulty]) {
                bestStreaks[currentDifficulty] = streakCount;
            }
            
            const modal = document.getElementById('mistake-modal');
            const explanation = document.getElementById('mistake-explanation');
            
            const levelName = currentDifficulty === 'level1' ? 'Level 1' : 
                            currentDifficulty === 'level2' ? 'Level 2' : 'Level 3';
            
            explanation.innerHTML = `
                <p><strong>${levelName} Complete</strong></p>
                <p>Score: ${streakCount}/15 correct</p>
                <br>
                <p>You need 15/15 to advance to the next level.</p>
                <p>Personal best: ${bestStreaks[currentDifficulty]}/15</p>
                <br>
                <p>Keep practicing! You're getting better!</p>
            `;
            
            modal.style.display = 'block';
        }
        
        // Handle successful level completion
        function handleLevelComplete() {
            gameActive = false;
            currentAnswer = null; // Clear stale data
            completedLevels.add(currentDifficulty);
            
            const modal = document.getElementById('level-complete-modal');
            const title = document.getElementById('level-complete-title');
            const message = document.getElementById('level-complete-message');
            
            if (currentDifficulty === 'level1') {
                title.innerHTML = 'üéâ PERFECT! 15/15! üéâ';
                message.innerHTML = `
                    <p><strong>‚úÖ LEVEL 1 COMPLETE</strong></p>
                    <p>You've mastered the basics!</p>
                    <p><strong>üîì LEVEL 2 UNLOCKED</strong></p>
                    <p>Ready for the next challenge? No more hints!</p>
                `;
            } else if (currentDifficulty === 'level2') {
                title.innerHTML = 'üéâ PERFECT! 15/15! üéâ';
                message.innerHTML = `
                    <p><strong>‚úÖ LEVEL 2 COMPLETE</strong></p>
                    <p>Great job! You're getting good at this!</p>
                    <p><strong>üîì LEVEL 3 UNLOCKED</strong></p>
                    <p>Warning: Very challenging! Near-nuts hands only.</p>
                `;
            } else {
                title.innerHTML = 'üèÜ PERFECT GAME! üèÜ';
                message.innerHTML = `
                    <p><strong>‚úÖ ALL LEVELS COMPLETE!</strong></p>
                    <p>You got 45 hands in a row correct!</p>
                    <p>You are a true poker master!</p>
                    <p>Share your achievement!</p>
                `;
            }
            
            modal.style.display = 'block';
        }
        
        // Handle incorrect answer
        function handleMistake(userChoice, correctAnswer) {
            gameActive = false;
            currentAnswer = null; // Clear stale data
            
            // Mark all remaining dots as incorrect when timeout occurs
            if (userChoice.description === 'Time Out') {
                const dots = document.querySelectorAll('.progress-dots .dot');
                for (let i = totalHandsPlayed; i < MAX_HANDS; i++) {
                    if (dots[i]) {
                        dots[i].textContent = '‚óè';
                        dots[i].classList.add('incorrect');
                    }
                }
            }
            
            // Update personal best if current is better
            if (streakCount > bestStreaks[currentDifficulty]) {
                bestStreaks[currentDifficulty] = streakCount;
            }
            
            const modal = document.getElementById('mistake-modal');
            const modalTitle = document.getElementById('mistake-title');
            const explanation = document.getElementById('mistake-explanation');
            
            let explanationHTML = '';
            if (userChoice.description === 'Time Out') {
                // Set timeout-specific title
                modalTitle.innerHTML = '‚è±Ô∏è Time\'s Up!';
                explanationHTML = `
                    <p>You ran out of time!</p>
                `;
                // Never show hand details for timeout - game is over
            } else {
                // Set incorrect answer title
                modalTitle.innerHTML = '‚ùå Incorrect!';
                explanationHTML = `
                    <p><strong>You had:</strong> ${formatHoleCardsForDisplay(userChoice.holeCards)}</p>
                    <p>Which makes: ${formatHandForDisplay(userChoice.description)}</p>
                    <br>
                    <p><strong>The nuts was:</strong> ${formatHoleCardsForDisplay(correctAnswer.holeCards)}</p>
                    <p>Which makes: ${formatHandForDisplay(correctAnswer.description)}</p>
                `;
            }
            
            explanationHTML += `
                <br>
                <p><strong>${getLevelDisplayName()} Score:</strong> ${streakCount}/15</p>
                <p>Personal best: ${bestStreaks[currentDifficulty]}/15</p>
                <p>You must get 15 correct in a row to advance.</p>
            `;
            
            explanation.innerHTML = explanationHTML;
            
            modal.style.display = 'block';
        }
        
        // Continue to next level
        function continueToNextLevel() {
            const modal = document.getElementById('level-complete-modal');
            modal.style.display = 'none';
            
            // Progress to next difficulty
            if (currentDifficulty === 'level1') {
                currentDifficulty = 'level2';
            } else if (currentDifficulty === 'level2') {
                currentDifficulty = 'level3';
            } else {
                // Game complete - show final results
                endGame();
                return;
            }
            
            // Reset for new level
            streakCount = 0;
            attemptCounts[currentDifficulty]++;
            startNewGame();
        }
        
        // Restart current level after mistake
        function restartCurrentLevel() {
            const modal = document.getElementById('mistake-modal');
            modal.style.display = 'none';
            
            // Reset streak but stay on same difficulty
            streakCount = 0;
            attemptCounts[currentDifficulty]++;
            startNewGame();
        }
        
        // Update progress dots display
        function updateProgressDots(isCorrect) {
            // Update the dot for the current hand (totalHandsPlayed - 1 because we just incremented it)
            const dotIndex = totalHandsPlayed - 1;
            const dots = document.querySelectorAll('.progress-dots .dot');
            if (dots[dotIndex]) {
                dots[dotIndex].textContent = '‚óè';
                dots[dotIndex].classList.add(isCorrect ? 'correct' : 'incorrect');
            }
        }
        
        // Legacy function kept for compatibility
        function updateProgressDisplay() {
            // No longer needed as we update dots directly in selectAnswer
        }
        
        function nextRound() {
            if (!gameActive) return;
            
            roundActive = true;
            
            // Clear previous round's button states
            const buttons = document.querySelectorAll('.choice-btn');
            buttons.forEach(btn => {
                btn.classList.remove('correct', 'incorrect');
                btn.disabled = false;
                btn.blur(); // Remove any lingering focus
            });
            
            // Use pre-generated scenarios
            if (currentScenarioIndex >= preGeneratedScenarios.length) {
                // Generate more scenarios if we run out
                preGenerateScenarios(20);
                currentScenarioIndex = 0;
            }
            
            const scenario = preGeneratedScenarios[currentScenarioIndex++];
            currentAnswer = scenario.answer;
            
            renderCards(scenario.communityCards, 'community-cards');
            renderChoices(scenario.choices);
        }

        function startNewGame() {
            // Always reset these for a new game
            score = 0;
            totalHandsPlayed = 0;
            streakCount = 0;
            
            // Reset pause state
            isPaused = false;
            pausedElapsedTime = 0;
            pauseStartTime = null;
            document.getElementById('countdown').classList.remove('paused');
            
            document.getElementById('score').textContent = score;
            document.getElementById('game-over').style.display = 'none';
            
            // Show the cards and choices areas again
            document.querySelector('.cards-area').style.display = 'block';
            document.getElementById('choices-area').style.display = 'block';
            
            // Initialize seeded random with current hour's seed + difficulty offset
            const seed = getDailySeed() + (currentDifficulty === 'level1' ? 0 : currentDifficulty === 'level2' ? 1000 : 2000);
            seedRandom = mulberry32(seed);
            
            // Reset progress dots
            const dots = document.querySelectorAll('.progress-dots .dot');
            dots.forEach(dot => {
                dot.textContent = '‚óã';
                dot.classList.remove('correct', 'incorrect');
            });
            
            // Update progress display
            updateProgressDisplay();
            
            // Pre-generate scenarios for consistent gameplay
            currentScenarioIndex = 0;
            preGenerateScenarios(MAX_HANDS); // Generate exactly the number we need
            
            // Start the game
            gameActive = true;
            startCountdown();
            nextRound();
        }

        function endGame() {
            gameActive = false;
            roundActive = false;
            stopCountdown();
            
            const resultDiv = document.getElementById('game-over');
            const resultMessage = document.getElementById('result-message');
            
            // Build results message based on progress
            let message = '';
            if (completedLevels.has('level3')) {
                message = `<strong>üèÜ PERFECT GAME! üèÜ</strong><br>
                          You completed all 45 hands perfectly!<br>
                          LEVEL 1 ‚úÖ LEVEL 2 ‚úÖ LEVEL 3 ‚úÖ<br>
                          You are a true poker master!`;
            } else if (completedLevels.has('level2')) {
                message = `<strong>Great job!</strong><br>
                          LEVEL 1 ‚úÖ LEVEL 2 ‚úÖ<br>
                          LEVEL 3: Best streak ${bestStreaks.level3}/15<br>
                          Keep practicing to master Level 3!`;
            } else if (completedLevels.has('level1')) {
                message = `<strong>Good progress!</strong><br>
                          LEVEL 1 ‚úÖ<br>
                          LEVEL 2: Best streak ${bestStreaks.level2}/15<br>
                          You're ready for the challenge!`;
            } else {
                message = `<strong>Keep practicing!</strong><br>
                          LEVEL 1: Best streak ${bestStreaks.level1}/15<br>
                          You need 15 perfect to unlock Level 2!<br>
                          Don't give up!`;
            }
            
            message += `<br><br>Share your progress and compete with friends!`;
            resultMessage.innerHTML = message;
            
            resultDiv.style.display = 'block';
            
            // Hide the cards and choices areas to avoid scrolling on mobile
            document.querySelector('.cards-area').style.display = 'none';
            document.getElementById('choices-area').style.display = 'none';
            
            // Disable all choice buttons
            const buttons = document.querySelectorAll('.choice-btn');
            buttons.forEach(btn => {
                btn.disabled = true;
            });
        }

        function getTimeWindow() {
            const now = new Date();
            const currentHour = now.getUTCHours();
            const nextHour = (currentHour + 1) % 24;
            
            const formatHour = (h) => {
                const period = h >= 12 ? 'PM' : 'AM';
                const hour12 = h === 0 ? 12 : (h > 12 ? h - 12 : h);
                return `${hour12}${period}`;
            };
            
            return `${formatHour(currentHour)}-${formatHour(nextHour)} UTC`;
        }

        function shareResults() {
            const timeWindow = getTimeWindow();
            let shareText = `üÉè The Nuts - Poker Challenge\n${timeWindow}\n\n`;
            
            // Build share text based on progress
            if (completedLevels.has('level3')) {
                // Perfect game!
                shareText += `üèÜ PERFECT GAME! üèÜ\n`;
                shareText += `‚úÖ LEVEL 1: 15/15\n`;
                shareText += `‚úÖ LEVEL 2: 15/15\n`;
                shareText += `‚úÖ LEVEL 3: 15/15\n`;
                shareText += `\n45 PERFECT HANDS IN A ROW!\n`;
                shareText += `Attempts: L1:${attemptCounts.level1}, L2:${attemptCounts.level2}, L3:${attemptCounts.level3}\n`;
            } else if (completedLevels.has('level2')) {
                // Completed level 2, working on level 3
                shareText += `‚úÖ LEVEL 1: PERFECT!\n`;
                shareText += `‚úÖ LEVEL 2: PERFECT!\n`;
                shareText += `üî¥ LEVEL 3: ${bestStreaks.level3}/15 (Best Streak)\n`;
                shareText += `üî• On fire! 30+ correct!\n`;
            } else if (completedLevels.has('level1')) {
                // Completed level 1, working on level 2
                shareText += `‚úÖ LEVEL 1: PERFECT!\n`;
                shareText += `üü° LEVEL 2: ${bestStreaks.level2}/15 (Best Streak)\n`;
                shareText += `Still learning the advanced plays!\n`;
            } else {
                // Still on level 1
                shareText += `üü¢ LEVEL 1: ${bestStreaks.level1}/15 (Best Streak)\n`;
                if (bestStreaks.level1 < 5) {
                    shareText += `‚ùå Still learning the basics!\n`;
                } else if (bestStreaks.level1 < 10) {
                    shareText += `üìà Getting better!\n`;
                } else {
                    shareText += `üî• Almost there!\n`;
                }
            }
            
            shareText += `\nCan you get 15 perfect?\n`;
            shareText += `Play at: ${window.location.href}`;
            
            // Check if Web Share API is available (for mobile devices)
            if (navigator.share && /mobile|android|iphone|ipad|ipod/i.test(navigator.userAgent)) {
                // Use native share for mobile devices
                navigator.share({
                    title: 'The Nuts - Poker Challenge',
                    text: shareText
                }).then(() => {
                    // Successfully shared
                    console.log('Shared successfully');
                }).catch((error) => {
                    // User cancelled or error occurred, fall back to clipboard
                    if (error.name !== 'AbortError') {
                        copyToClipboard(shareText);
                    }
                });
            } else {
                // Desktop or no Web Share API support - copy to clipboard
                copyToClipboard(shareText);
            }
        }
        
        function copyToClipboard(text) {
            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showToast('Results copied to clipboard!');
                }).catch(err => {
                    // Fallback for older browsers
                    fallbackCopyToClipboard(text);
                });
            } else {
                // Use fallback method
                fallbackCopyToClipboard(text);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            showToast('Results copied to clipboard!');
        }
        
        function showToast(message) {
            const toast = document.getElementById('copied-toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        function showHelp() {
            document.getElementById('help-modal').classList.add('active');
        }

        function closeHelp() {
            document.getElementById('help-modal').classList.remove('active');
        }

        // Close modal when clicking outside
        document.getElementById('help-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeHelp();
            }
        });
    </script>
</body>
</html>