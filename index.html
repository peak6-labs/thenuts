<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Nuts - Poker Training Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #6B2B9E 0%, #9C27B0 50%, #CE93D8 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: #FAFAFA;
            border-radius: 20px;
            padding: 30px;
            max-width: 800px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(107, 43, 158, 0.3);
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .title {
            font-size: 32px;
            font-weight: 800;
            color: #6B2B9E;
            letter-spacing: -0.5px;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .help-btn, .new-game-btn {
            background: #9C27B0;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(156, 39, 176, 0.3);
        }

        .help-btn:hover, .new-game-btn:hover {
            background: #7B1FA2;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.4);
        }

        .help-btn {
            width: 40px;
            height: 40px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            border-radius: 50%;
            background: #E1BEE7;
            color: #6B2B9E;
            box-shadow: 0 2px 8px rgba(107, 43, 158, 0.2);
        }

        .help-btn:hover {
            background: #CE93D8;
            color: white;
        }

        .timer-display {
            font-size: 22px;
            font-weight: 700;
            color: #D32F2F;
            min-width: 70px;
            display: inline-block;
            text-align: center;
            background: #FFEBEE;
            padding: 5px 10px;
            border-radius: 20px;
        }

        .score-display {
            font-size: 18px;
            font-weight: 600;
            color: #6B2B9E;
            margin-left: 15px;
            background: #F3E5F5;
            padding: 5px 15px;
            border-radius: 20px;
        }

        .cards-area {
            margin-bottom: 25px;
        }

        .section-label {
            font-size: 13px;
            color: #9C27B0;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 700;
        }

        .cards {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .card {
            width: 75px;
            height: 105px;
            border: none;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: white;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transition: transform 0.3s;
            position: relative;
        }

        .card:hover {
            transform: translateY(-8px) scale(1.05);
            box-shadow: 0 8px 20px rgba(107, 43, 158, 0.25);
        }

        .card.red {
            color: #E91E63;
        }

        .card.black {
            color: #424242;
        }

        .card-rank {
            font-size: 32px;
            font-weight: 700;
            line-height: 1;
        }

        .card-suit {
            font-size: 28px;
            margin-top: 2px;
        }

        .choices {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 25px;
        }

        .choice-btn {
            padding: 18px;
            border: 2px solid #CE93D8;
            background: white;
            border-radius: 15px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        /* Only apply hover on non-touch devices */
        @media (hover: hover) {
            .choice-btn:hover {
                background: linear-gradient(135deg, #9C27B0, #AB47BC);
                color: white;
                border-color: #9C27B0;
                transform: translateY(-3px);
                box-shadow: 0 6px 20px rgba(156, 39, 176, 0.3);
            }
        }

        .choice-btn.correct {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            border-color: #4CAF50;
        }

        .choice-btn.incorrect {
            background: linear-gradient(135deg, #F44336, #EF5350);
            color: white;
            border-color: #F44336;
        }

        .choice-btn:disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Prevent sticky focus/active states on mobile */
        .choice-btn:focus {
            outline: none;
        }

        .choice-btn:active {
            transform: translateY(-1px);
        }

        /* Remove tap highlight on mobile */
        .choice-btn {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 35px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(107, 43, 158, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 28px;
            color: #6B2B9E;
            font-weight: 800;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 32px;
            cursor: pointer;
            color: #CE93D8;
            transition: color 0.3s;
        }

        .close-btn:hover {
            color: #9C27B0;
        }

        .modal-body {
            line-height: 1.6;
            color: #34495e;
        }

        .modal-body h3 {
            margin-top: 25px;
            margin-bottom: 12px;
            color: #6B2B9E;
            font-weight: 700;
        }

        .modal-body ul {
            margin-left: 20px;
        }

        .game-over {
            text-align: center;
            padding: 25px;
            background: linear-gradient(135deg, #F3E5F5, #FCE4EC);
            border-radius: 15px;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(107, 43, 158, 0.1);
        }

        .game-over h2 {
            color: #6B2B9E;
            margin-bottom: 15px;
            font-size: 28px;
            font-weight: 800;
        }

        .game-over p {
            color: #7f8c8d;
            margin-bottom: 15px;
        }

        .share-btn {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 0 5px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .share-btn:hover {
            background: linear-gradient(135deg, #388E3C, #4CAF50);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .copied-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #6B2B9E, #9C27B0);
            color: white;
            padding: 14px 28px;
            border-radius: 25px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 2000;
            box-shadow: 0 6px 20px rgba(107, 43, 158, 0.4);
            font-weight: 600;
        }

        .copied-toast.show {
            opacity: 1;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }

        @media (max-width: 600px) {
            .game-container {
                padding: 15px;
            }

            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            .title {
                font-size: 24px;
            }

            .controls {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
            }

            .timer-display {
                font-size: 18px;
                min-width: 65px;
                padding: 4px 8px;
            }

            .score-display {
                font-size: 14px;
                padding: 4px 10px;
            }

            .card {
                width: 60px;
                height: 85px;
            }

            .card-rank {
                font-size: 24px;
            }

            .card-suit {
                font-size: 20px;
            }

            .choices {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <!-- Load pokersolver library from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/pokersolver@2.1.4/pokersolver.min.js"></script>
    <!-- Version: 2.0 - Purple Theme Update -->
</head>
<body>
    <div class="game-container">
        <div id="loading" class="loading">Loading poker library...</div>
        
        <div id="game-content" style="display: none;">
            <div class="header">
                <h1 class="title">Find The Nuts!</h1>
                <div class="controls">
                    <div class="timer-display" id="countdown">60.0s (0/15)</div>
                    <div class="score-display">Correct: <span id="score">0</span></div>
                    <button class="help-btn" onclick="showHelp()">?</button>
                    <button class="new-game-btn" onclick="startNewGame()">New Game</button>
                </div>
            </div>

            <div class="cards-area">
                <div class="section-label">Community Cards</div>
                <div class="cards" id="community-cards"></div>
            </div>

            <div class="choices-area" id="choices-area">
                <div class="section-label">What is the nuts? (The best possible hand ANY player could have)</div>
                <div class="choices" id="choices"></div>
            </div>

            <div id="game-over" class="game-over" style="display: none;">
                <h2>Game Over!</h2>
                <p id="result-message"></p>
                <div>
                    <button class="share-btn" onclick="shareResults()">Share Results</button>
                    <button class="new-game-btn" onclick="startNewGame()">Play Again</button>
                </div>
            </div>
        </div>
    </div>

    <div id="copied-toast" class="copied-toast">Results copied to clipboard!</div>

    <div id="help-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">How to Play</h2>
                <button class="close-btn" onclick="closeHelp()">&times;</button>
            </div>
            <div class="modal-body">
                <h3>What is "The Nuts"?</h3>
                <p>In poker, "the nuts" refers to the best possible hand that can be made given the community cards on the board. It's the unbeatable hand at that moment.</p>
                
                <p><strong>IMPORTANT:</strong> The nuts is NOT necessarily the hand YOU have with your hole cards. It's the best hand that ANY player could theoretically have. Your hole cards are shown for reference, but you need to imagine what the best possible hole cards would be!</p>
                
                <h3>How to Identify The Nuts:</h3>
                <ul>
                    <li>Look at all 5 community cards</li>
                    <li>Imagine what 2 hole cards would make the strongest possible hand</li>
                    <li>Ignore YOUR actual hole cards - think theoretically</li>
                    <li>Consider all possibilities: straight flushes, four of a kind, full houses, etc.</li>
                </ul>
                
                <h3>Example:</h3>
                <p>If the board shows: 10♣ 10♠ 3♥ K♣ 8♥<br>
                The nuts would be Four 10s (if someone has 10♥ 10♦)<br>
                Even if YOU only have a pair of 3s!</p>

                <h3>Hand Rankings (from best to worst):</h3>
                <ol>
                    <li><strong>Royal Flush</strong> - A, K, Q, J, 10 all same suit</li>
                    <li><strong>Straight Flush</strong> - Five cards in sequence, same suit</li>
                    <li><strong>Four of a Kind</strong> - Four cards of same rank</li>
                    <li><strong>Full House</strong> - Three of a kind + pair</li>
                    <li><strong>Flush</strong> - Five cards of same suit</li>
                    <li><strong>Straight</strong> - Five cards in sequence</li>
                    <li><strong>Three of a Kind</strong> - Three cards of same rank</li>
                    <li><strong>Two Pair</strong> - Two different pairs</li>
                    <li><strong>One Pair</strong> - Two cards of same rank</li>
                    <li><strong>High Card</strong> - Highest single card</li>
                </ol>

                <h3>Game Objective:</h3>
                <p>You have 60 seconds or 15 hands (whichever comes first) to correctly identify as many nuts as possible! Each correct answer adds to your score. The game uses seeded randomness based on the current hour (UTC), so everyone playing during the same hour gets the exact same sequence of hands - compete with friends for the high score!</p>
            </div>
        </div>
    </div>

    <script>
        // Wait for pokersolver to load
        window.addEventListener('load', function() {
            if (typeof Hand !== 'undefined') {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('game-content').style.display = 'block';
                initializeGame();
            } else {
                document.getElementById('loading').textContent = 'Error loading poker library. Please refresh the page.';
            }
        });

        // Game state
        let gameStartTime = null;
        let countdownInterval = null;
        let currentAnswer = null;
        let score = 0;
        let gameActive = false;
        let roundActive = false;
        let seedRandom = null;
        let seedCounter = 0;
        let preGeneratedScenarios = [];
        let currentScenarioIndex = 0;
        let totalHandsPlayed = 0;
        const MAX_HANDS = 15;
        // Hand will be available globally from pokersolver

        // Card representations
        const suits = ['♠', '♥', '♦', '♣'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

        class Card {
            constructor(rank, suit) {
                this.rank = rank;
                this.suit = suit;
            }

            isRed() {
                return this.suit === '♥' || this.suit === '♦';
            }

            // Convert to pokersolver format (e.g., "As", "Td", "7h")
            toPokerSolverString() {
                const rankMap = {
                    '10': 'T',
                    'J': 'J',
                    'Q': 'Q',
                    'K': 'K',
                    'A': 'A'
                };
                const suitMap = {
                    '♠': 's',
                    '♥': 'h',
                    '♦': 'd',
                    '♣': 'c'
                };
                const psRank = rankMap[this.rank] || this.rank;
                const psSuit = suitMap[this.suit];
                return psRank + psSuit;
            }
        }

        class Deck {
            constructor() {
                this.reset();
            }

            reset() {
                this.cards = [];
                for (let suit of suits) {
                    for (let rank of ranks) {
                        this.cards.push(new Card(rank, suit));
                    }
                }
                this.shuffle();
            }

            shuffle() {
                for (let i = this.cards.length - 1; i > 0; i--) {
                    const j = Math.floor(seededRandom() * (i + 1));
                    [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
                }
            }

            draw(n = 1) {
                const drawn = [];
                for (let i = 0; i < n; i++) {
                    if (this.cards.length > 0) {
                        drawn.push(this.cards.pop());
                    }
                }
                return drawn;
            }
        }

        // Seeded random number generator
        function mulberry32(a) {
            return function() {
                let t = a += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        function seededRandom() {
            if (seedRandom) {
                return seedRandom();
            }
            return Math.random();
        }

        function getDailySeed() {
            // Use current date (UTC) to hour precision for seed
            // This gives everyone the same seed for each hour
            const now = new Date();
            const seed = now.getUTCFullYear() * 10000000 + 
                        (now.getUTCMonth() + 1) * 100000 + 
                        now.getUTCDate() * 1000 + 
                        now.getUTCHours();
            return seed;
        }

        function testPokerSolverUsage() {
            console.log('=== Testing PokerSolver Card Conversion and Comparison ===');
            
            // Test 1: Card conversion
            console.log('\nTest 1: Card Conversion');
            const testCard = new Card('A', '♠');
            console.log('Our card:', testCard.rank, testCard.suit);
            console.log('Converted to pokersolver:', testCard.toPokerSolverString());
            console.log('Expected: As');
            
            // Test 2: Compare two flushes
            console.log('\nTest 2: Comparing Flushes');
            const aceHighFlush = Hand.solve(['Ah', 'Kh', '9h', '5h', '2h']);
            const nineHighFlush = Hand.solve(['9h', '8h', '5h', '3h', '2h']);
            console.log('Ace-high flush:', aceHighFlush.descr);
            console.log('Nine-high flush:', nineHighFlush.descr);
            console.log('aceHighFlush.compare(nineHighFlush):', aceHighFlush.compare(nineHighFlush));
            console.log('nineHighFlush.compare(aceHighFlush):', nineHighFlush.compare(aceHighFlush));
            const flushWinner = Hand.winners([aceHighFlush, nineHighFlush]);
            console.log('Hand.winners() says:', flushWinner[0].descr, 'should win');
            console.log('Expected: Ace-high flush should win');
            
            // Test 3: Compare two four of a kinds
            console.log('\nTest 3: Comparing Four of a Kinds');
            const quadKings = Hand.solve(['Kh', 'Kd', 'Kc', 'Ks', '2h']);
            const quadEights = Hand.solve(['8h', '8d', '8c', '8s', '2h']);
            console.log('Quad Kings:', quadKings.descr);
            console.log('Quad Eights:', quadEights.descr);
            console.log('quadKings.compare(quadEights):', quadKings.compare(quadEights));
            console.log('quadEights.compare(quadKings):', quadEights.compare(quadKings));
            const quadWinner = Hand.winners([quadKings, quadEights]);
            console.log('Hand.winners() says:', quadWinner[0].descr, 'should win');
            console.log('Expected: Quad Kings should win');
        }
        
        function testSpecificBoard() {
            // Run pokersolver tests first
            testPokerSolverUsage();
            console.log('\n=== Testing Specific Boards ===\n');
            // Test a board where we expect certain hands
            // Board: K K 8 8 2 (two pair on board)
            const testBoard = [
                new Card('K', '♠'),
                new Card('K', '♥'),
                new Card('8', '♣'),
                new Card('8', '♦'),
                new Card('2', '♠')
            ];
            
            console.log('=== Testing specific board: K♠ K♥ 8♣ 8♦ 2♠ ===');
            
            const boardStrings = cardsToPokerSolverArray(testBoard);
            
            // Test pocket K-K (would make quad Kings)
            const pocketKK = [new Card('K', '♣'), new Card('K', '♦')];
            const handKK = Hand.solve([...boardStrings, ...cardsToPokerSolverArray(pocketKK)]);
            console.log('With pocket K♣ K♦:', handKK.descr, 'rank:', handKK.rank);
            
            // Test pocket 8-8 (would make quad 8s)
            const pocket88 = [new Card('8', '♠'), new Card('8', '♥')];
            const hand88 = Hand.solve([...boardStrings, ...cardsToPokerSolverArray(pocket88)]);
            console.log('With pocket 8♠ 8♥:', hand88.descr, 'rank:', hand88.rank);
            
            // Compare them
            console.log('Comparing: handKK.compare(hand88) =', handKK.compare(hand88));
            console.log('Comparing: hand88.compare(handKK) =', hand88.compare(handKK));
            console.log('handKK cards:', handKK.cards);
            console.log('hand88 cards:', hand88.cards);
            
            const nuts = findTheNuts(testBoard);
            console.log('\nThe nuts for this board:', nuts);
            console.log('Expected: Four of a Kind, Ks (Kings beat 8s)');
            
            // Test another board
            // Board: A A A 5 5 (full house on board itself)
            const testBoard2 = [
                new Card('A', '♠'),
                new Card('A', '♥'),
                new Card('A', '♣'),
                new Card('5', '♦'),
                new Card('5', '♠')
            ];
            
            console.log('\n=== Testing specific board: A♠ A♥ A♣ 5♦ 5♠ ===');
            
            const boardStrings2 = cardsToPokerSolverArray(testBoard2);
            
            // Test pocket A-x (would make quad Aces)
            const pocketA = [new Card('A', '♦'), new Card('7', '♥')];
            const handA = Hand.solve([...boardStrings2, ...cardsToPokerSolverArray(pocketA)]);
            console.log('With pocket A♦ 7♥:', handA.descr, 'rank:', handA.rank);
            
            // Test pocket 5-5 (would make quad 5s - impossible but let's test)
            const pocket5 = [new Card('5', '♣'), new Card('5', '♥')];
            const hand5 = Hand.solve([...boardStrings2, ...cardsToPokerSolverArray(pocket5)]);
            console.log('With pocket 5♣ 5♥:', hand5.descr, 'rank:', hand5.rank);
            
            // Compare them
            console.log('Comparing: handA.compare(hand5) =', handA.compare(hand5));
            console.log('Comparing: hand5.compare(handA) =', hand5.compare(handA));
            
            const nuts2 = findTheNuts(testBoard2);
            console.log('\nThe nuts for this board:', nuts2);
            console.log('Expected: Four of a Kind, As (Aces beat 5s)');
            
            // Test a board with single pair where Full House should be nuts
            // Board: Q Q 7 3 2 rainbow
            const testBoard3 = [
                new Card('Q', '♠'),
                new Card('Q', '♥'),
                new Card('7', '♣'),
                new Card('3', '♦'),
                new Card('2', '♠')
            ];
            
            console.log('\n=== Testing specific board: Q♠ Q♥ 7♣ 3♦ 2♠ ===');
            const nuts3 = findTheNuts(testBoard3);
            console.log('The nuts for this board:', nuts3);
            console.log('Expected: Four of a Kind (Quad Queens)');
            
            // Test a board where Full House IS the nuts
            // Board with trips: 9 9 9 K 2 (no quads possible)
            const testBoard4 = [
                new Card('9', '♠'),
                new Card('9', '♥'),
                new Card('9', '♣'),
                new Card('K', '♦'),
                new Card('2', '♠')
            ];
            
            console.log('\n=== Testing specific board: 9♠ 9♥ 9♣ K♦ 2♠ ===');
            const nuts4 = findTheNuts(testBoard4);
            console.log('The nuts for this board:', nuts4);
            console.log('Expected: Four of a Kind, 9s (pocket 9-x makes quad nines)');
            
            // Test a board where the board itself is a full house
            // Board: 7 7 7 3 3 - Best would be quad 7s or quad 3s
            const testBoard5 = [
                new Card('7', '♠'),
                new Card('7', '♥'),
                new Card('7', '♣'),
                new Card('3', '♦'),
                new Card('3', '♠')
            ];
            
            console.log('\n=== Testing specific board: 7♠ 7♥ 7♣ 3♦ 3♠ ===');
            const nuts5 = findTheNuts(testBoard5);
            console.log('The nuts for this board:', nuts5);
            console.log('Expected: Four of a Kind, 7s (pocket 7-x makes quad sevens)');
            
            console.log('\n=== CONCLUSION ===');
            console.log('Full House can never be the nuts because:');
            console.log('- If there\'s a pair on board, pocket pair makes quads');
            console.log('- If there are trips on board, the 4th card makes quads');
            console.log('- If board has full house, pocket card can make quads');
            console.log('This explains why we see 0% Full House in generation!');
            
            // Test if two pair can ever be the nuts
            // First test: 2-3-7-8-A
            const testBoard6 = [
                new Card('2', '♠'),
                new Card('3', '♥'),
                new Card('7', '♣'),
                new Card('8', '♦'),
                new Card('A', '♠')
            ];
            
            console.log('\n=== Testing: 2♠ 3♥ 7♣ 8♦ A♠ ===');
            const nuts6 = findTheNuts(testBoard6);
            console.log('The nuts for this board:', nuts6);
            console.log('Expected: Straight (4-5 makes wheel A-2-3-4-5) or Trips if no straight');
            
            // Test with maximum gaps to prevent straights - avoid Ace!
            // 2-4-7-J-K has no possible straights
            const testBoard7 = [
                new Card('2', '♠'),
                new Card('4', '♥'),
                new Card('7', '♣'),
                new Card('J', '♦'),
                new Card('K', '♣')
            ];
            
            console.log('\n=== Testing maximum gaps (no Ace): 2♠ 4♥ 7♣ J♦ K♣ ===');
            const nuts7 = findTheNuts(testBoard7);
            console.log('The nuts for this board:', nuts7);
            console.log('Analysis: No straight possible (no 5-card sequence). Should be Three of a Kind!');
            console.log('\nConclusion: Even without straights, pocket pairs make trips which beat two pair.');
            console.log('Therefore, Two Pair can NEVER be the nuts!');
        }
        
        function initializeGame() {
            // Hand is already available as a global from pokersolver
            document.querySelector('.new-game-btn').onclick = startNewGame;
            
            // Run test first (disabled for production)
            // testSpecificBoard();
            
            startNewGame();
        }

        // Convert cards array to pokersolver format
        function cardsToPokerSolverArray(cards) {
            return cards.map(card => card.toPokerSolverString());
        }

        // Format pokersolver hand description for display
        function formatHandDescription(description) {
            // pokersolver returns descriptions like "Four of a Kind, A's"
            // We'll clean these up for consistent display
            // Just remove apostrophes, pokersolver already formats nicely
            return description.replace(/'/g, '');
        }

        // Find the absolute nuts using pokersolver
        function findTheNuts(communityCards) {
            const communityStrings = cardsToPokerSolverArray(communityCards);
            
            // Generate all remaining cards not on the board
            const remainingCards = [];
            for (let suit of suits) {
                for (let rank of ranks) {
                    const card = new Card(rank, suit);
                    if (!communityCards.some(cc => cc.rank === card.rank && cc.suit === card.suit)) {
                        remainingCards.push(card);
                    }
                }
            }
            
            let bestHand = null;
            let bestRank = -1;
            
            // Check all possible hole card combinations
            for (let i = 0; i < remainingCards.length - 1; i++) {
                for (let j = i + 1; j < remainingCards.length; j++) {
                    const holeCards = [remainingCards[i], remainingCards[j]];
                    const allCardStrings = [
                        ...communityStrings,
                        ...cardsToPokerSolverArray(holeCards)
                    ];
                    
                    // PokerSolver.Hand.solve automatically finds the best 5-card hand from 7 cards
                    const hand = Hand.solve(allCardStrings);
                    
                    // Use Hand.winners() to properly compare hands
                    // This handles all tie-breaker logic correctly
                    if (!bestHand) {
                        bestHand = hand;
                        bestRank = hand.rank;
                    } else {
                        // Let pokersolver determine the winner using Hand.winners()
                        const winners = Hand.winners([bestHand, hand]);
                        if (winners[0] === hand) {
                            bestHand = hand;
                            bestRank = hand.rank;
                        }
                        // If winners[0] === bestHand, keep current best
                    }
                }
            }
            
            return formatHandDescription(bestHand.descr);
        }

        // Find player's best hand
        function findPlayerBestHand(communityCards, holeCards) {
            const allCardStrings = [
                ...cardsToPokerSolverArray(communityCards),
                ...cardsToPokerSolverArray(holeCards)
            ];
            
            const hand = Hand.solve(allCardStrings);
            return formatHandDescription(hand.descr);
        }

        // Generate possible hands for wrong answers
        function generatePossibleHands(communityCards) {
            const possibleHands = new Set();
            const deck = new Deck();
            
            // Remove community cards from deck
            deck.cards = deck.cards.filter(card => 
                !communityCards.some(cc => cc.rank === card.rank && cc.suit === card.suit)
            );
            
            // Sample random hole card combinations
            for (let attempt = 0; attempt < 30; attempt++) {
                const i = Math.floor(seededRandom() * deck.cards.length);
                let j = Math.floor(seededRandom() * deck.cards.length);
                while (j === i) {
                    j = Math.floor(seededRandom() * deck.cards.length);
                }
                
                const sampleHoleCards = [deck.cards[i], deck.cards[j]];
                const allCardStrings = [
                    ...cardsToPokerSolverArray(communityCards),
                    ...cardsToPokerSolverArray(sampleHoleCards)
                ];
                
                const hand = Hand.solve(allCardStrings);
                possibleHands.add(formatHandDescription(hand.descr));
            }
            
            return Array.from(possibleHands);
        }

        function generateScenario() {
            const deck = new Deck();
            const communityCards = deck.draw(5);
            
            // Find the absolute nuts
            const theNuts = findTheNuts(communityCards);
            
            // Debug: Don't log anything for now to reduce noise
            
            // Generate choices
            const choices = new Set();
            choices.add(theNuts);
            
            // Generate other possible hands
            const possibleHands = generatePossibleHands(communityCards);
            for (let hand of possibleHands) {
                if (choices.size >= 4) break;
                if (!choices.has(hand)) {
                    choices.add(hand);
                }
            }
            
            // If we still need more choices, add the board play
            const boardOnly = Hand.solve(cardsToPokerSolverArray(communityCards));
            choices.add(formatHandDescription(boardOnly.descr));
            
            // Ensure we have 4 choices
            const choicesArray = Array.from(choices).slice(0, 4);
            
            // Shuffle choices
            for (let i = choicesArray.length - 1; i > 0; i--) {
                const j = Math.floor(seededRandom() * (i + 1));
                [choicesArray[i], choicesArray[j]] = [choicesArray[j], choicesArray[i]];
            }
            
            return {
                communityCards,
                choices: choicesArray,
                answer: theNuts
            };
        }

        function renderCard(card, container) {
            const cardDiv = document.createElement('div');
            cardDiv.className = `card ${card.isRed() ? 'red' : 'black'}`;
            cardDiv.innerHTML = `
                <div class="card-rank">${card.rank}</div>
                <div class="card-suit">${card.suit}</div>
            `;
            container.appendChild(cardDiv);
        }

        function renderCards(cards, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            cards.forEach(card => renderCard(card, container));
        }

        function renderChoices(choices) {
            const container = document.getElementById('choices');
            container.innerHTML = '';
            
            choices.forEach(choice => {
                const button = document.createElement('button');
                button.className = 'choice-btn';
                button.textContent = choice;
                button.onclick = (e) => {
                    e.preventDefault();
                    e.target.blur(); // Immediately blur on click
                    selectAnswer(choice);
                };
                container.appendChild(button);
            });
        }

        function startCountdown() {
            gameStartTime = Date.now();
            countdownInterval = setInterval(updateCountdown, 100);
        }

        function stopCountdown() {
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
        }

        function updateCountdown() {
            if (gameStartTime) {
                const elapsed = (Date.now() - gameStartTime) / 1000;
                const remaining = Math.max(0, 60 - elapsed);
                document.getElementById('countdown').textContent = `${remaining.toFixed(1)}s (${totalHandsPlayed}/${MAX_HANDS})`;
                
                if (remaining <= 0) {
                    endGame();
                }
            }
        }

        function selectAnswer(choice) {
            if (!roundActive || !gameActive) return;
            
            roundActive = false;
            totalHandsPlayed++;
            
            const buttons = document.querySelectorAll('.choice-btn');
            buttons.forEach(btn => {
                btn.disabled = true;
                // Remove focus from button to prevent sticky highlighting on mobile
                btn.blur();
                if (btn.textContent === currentAnswer) {
                    btn.classList.add('correct');
                } else if (btn.textContent === choice && choice !== currentAnswer) {
                    btn.classList.add('incorrect');
                }
            });
            
            if (choice === currentAnswer) {
                score++;
                document.getElementById('score').textContent = score;
            }
            
            // Update the display to show hands played
            updateCountdown();
            
            // Check if game should end (hit max hands)
            if (totalHandsPlayed >= MAX_HANDS) {
                setTimeout(() => {
                    endGame();
                }, 1500);
            } else {
                // Auto-advance to next round after a short delay
                setTimeout(() => {
                    if (gameActive) {
                        nextRound();
                    }
                }, 1000);
            }
        }

        function getHandTypeCategory(handDescription) {
            // Extract the base hand type from descriptions like "Four of a Kind, As"
            if (handDescription.includes('Royal Flush')) return 'Royal Flush';
            if (handDescription.includes('Straight Flush')) return 'Straight Flush';
            if (handDescription.includes('Four of a Kind')) return 'Four of a Kind';
            if (handDescription.includes('Full House')) return 'Full House';
            if (handDescription.includes('Flush')) return 'Flush';
            if (handDescription.includes('Straight')) return 'Straight';
            if (handDescription.includes('Three of a Kind')) return 'Three of a Kind';
            if (handDescription.includes('Two Pair')) return 'Two Pair';
            // Note: Pair and High Card should never appear as the nuts
            if (handDescription.includes('Pair')) return 'Pair';
            return 'High Card';
        }

        function preGenerateScenarios(count) {
            preGeneratedScenarios = [];
            const handTypeCounts = {};  // Tracks accepted scenarios
            const generatedTypeCounts = {};  // Tracks ALL generated scenarios
            const MAX_PER_TYPE = 3;  // Changed from 2 to 3 since only 6 hand types are possible as nuts
            let attempts = 0;
            const MAX_ATTEMPTS = count * 100; // More attempts for better variety
            let rejectCount = 0;
            const rejectedTypes = {}; // Track rejections by type
            
            // console.log('Starting scenario generation for', count, 'hands');
            
            while (preGeneratedScenarios.length < count && attempts < MAX_ATTEMPTS) {
                attempts++;
                const scenario = generateScenario();
                const handType = getHandTypeCategory(scenario.answer);
                
                // Track ALL generated types
                if (!generatedTypeCounts[handType]) {
                    generatedTypeCounts[handType] = 0;
                }
                generatedTypeCounts[handType]++;
                
                // Initialize accepted counter if needed
                if (!handTypeCounts[handType]) {
                    handTypeCounts[handType] = 0;
                }
                
                if (handTypeCounts[handType] < MAX_PER_TYPE) {
                    handTypeCounts[handType]++;
                    preGeneratedScenarios.push(scenario);
                    // Removed individual logging to reduce clutter
                } else {
                    // Track rejections silently
                    rejectCount++;
                    if (!rejectedTypes[handType]) {
                        rejectedTypes[handType] = 0;
                    }
                    rejectedTypes[handType]++;
                    
                    // Only log every 100 rejections to reduce spam
                    if (rejectCount % 100 === 0) {
                        console.log(`Progress: ${rejectCount} rejections, ${preGeneratedScenarios.length}/${count} scenarios found`);
                    }
                }
            }
            
            // Only fill remaining if we really couldn't generate enough variety
            if (preGeneratedScenarios.length < count) {
                console.warn(`Could only generate ${preGeneratedScenarios.length}/${count} scenarios with variety limits.`);
                console.warn(`Filling remaining slots - variety limits will be exceeded.`);
                
                // Just fill the remaining slots
                while (preGeneratedScenarios.length < count) {
                    const scenario = generateScenario();
                    const handType = getHandTypeCategory(scenario.answer);
                    
                    if (!handTypeCounts[handType]) {
                        handTypeCounts[handType] = 0;
                    }
                    handTypeCounts[handType]++;
                    
                    if (!generatedTypeCounts[handType]) {
                        generatedTypeCounts[handType] = 0;
                    }
                    generatedTypeCounts[handType]++;
                    
                    preGeneratedScenarios.push(scenario);
                    console.log(`Overflow: Added ${handType} (now at ${handTypeCounts[handType]} total)`);
                }
            }
            
            // Log final summary
            console.log('=== Generation Summary ===');
            console.log('Accepted distribution:', handTypeCounts);
            console.log(`Total: ${preGeneratedScenarios.length} scenarios from ${attempts} attempts (${rejectCount} rejected)`);
            
            // Show which types were rejected most
            if (Object.keys(rejectedTypes).length > 0) {
                console.log('Rejected by type:', rejectedTypes);
            }
            
            // Create comprehensive generation report
            console.log('\n=== Generation Report ===');
            console.log(`Total Generated: ${attempts}`);
            
            // All possible hand types that can actually be the nuts
            // (Pair and High Card can never be the nuts)
            const allHandTypes = [
                'Royal Flush', 'Straight Flush', 'Four of a Kind',
                'Full House', 'Flush', 'Straight',
                'Three of a Kind', 'Two Pair'
            ];
            
            // Sort by count (descending)
            const sortedTypes = allHandTypes.map(type => ({
                type: type,
                count: generatedTypeCounts[type] || 0,
                percentage: ((generatedTypeCounts[type] || 0) / attempts * 100).toFixed(1)
            })).sort((a, b) => b.count - a.count);
            
            console.log('\nBreakdown by hand type:');
            sortedTypes.forEach(item => {
                const bar = '█'.repeat(Math.floor(item.percentage / 2)); // Visual bar
                console.log(`${item.count.toString().padStart(4)} ${item.type.padEnd(20)} ${item.percentage.padStart(5)}% ${bar}`);
            });
            
            // Show acceptance rate
            console.log('\n=== Acceptance Rates ===');
            allHandTypes.forEach(type => {
                const generated = generatedTypeCounts[type] || 0;
                const accepted = handTypeCounts[type] || 0;
                if (generated > 0) {
                    const acceptRate = (accepted / generated * 100).toFixed(1);
                    console.log(`${type.padEnd(20)}: ${accepted}/${generated} accepted (${acceptRate}%)`);
                }
            });
        }

        function nextRound() {
            if (!gameActive) return;
            
            roundActive = true;
            
            // Clear previous round's button states
            const buttons = document.querySelectorAll('.choice-btn');
            buttons.forEach(btn => {
                btn.classList.remove('correct', 'incorrect');
                btn.disabled = false;
                btn.blur(); // Remove any lingering focus
            });
            
            // Use pre-generated scenarios
            if (currentScenarioIndex >= preGeneratedScenarios.length) {
                // Generate more scenarios if we run out
                preGenerateScenarios(20);
                currentScenarioIndex = 0;
            }
            
            const scenario = preGeneratedScenarios[currentScenarioIndex++];
            currentAnswer = scenario.answer;
            
            renderCards(scenario.communityCards, 'community-cards');
            renderChoices(scenario.choices);
        }

        function startNewGame() {
            // Reset game state
            score = 0;
            totalHandsPlayed = 0;
            document.getElementById('score').textContent = score;
            document.getElementById('game-over').style.display = 'none';
            
            // Show the cards and choices areas again
            document.querySelector('.cards-area').style.display = 'block';
            document.getElementById('choices-area').style.display = 'block';
            
            // Initialize seeded random with current hour's seed
            const seed = getDailySeed();
            seedRandom = mulberry32(seed);
            
            // Pre-generate scenarios for consistent gameplay
            currentScenarioIndex = 0;
            preGenerateScenarios(MAX_HANDS); // Generate exactly the number we need
            
            // Start the game
            gameActive = true;
            startCountdown();
            nextRound();
        }

        function endGame() {
            gameActive = false;
            roundActive = false;
            stopCountdown();
            
            const resultDiv = document.getElementById('game-over');
            const resultMessage = document.getElementById('result-message');
            
            const winPercentage = Math.round((score / MAX_HANDS) * 100);
            
            resultMessage.innerHTML = `<strong>Final Score: ${score}/${MAX_HANDS} (${winPercentage}%)</strong><br>
                                      Everyone playing this hour gets the same sequence of hands.<br>
                                      Share your score and compete with friends!`;
            
            resultDiv.style.display = 'block';
            
            // Hide the cards and choices areas to avoid scrolling on mobile
            document.querySelector('.cards-area').style.display = 'none';
            document.getElementById('choices-area').style.display = 'none';
            
            // Disable all choice buttons
            const buttons = document.querySelectorAll('.choice-btn');
            buttons.forEach(btn => {
                btn.disabled = true;
            });
        }

        function getTimeWindow() {
            const now = new Date();
            const currentHour = now.getUTCHours();
            const nextHour = (currentHour + 1) % 24;
            
            const formatHour = (h) => {
                const period = h >= 12 ? 'PM' : 'AM';
                const hour12 = h === 0 ? 12 : (h > 12 ? h - 12 : h);
                return `${hour12}${period}`;
            };
            
            return `${formatHour(currentHour)}-${formatHour(nextHour)} UTC`;
        }

        function shareResults() {
            const winPercentage = Math.round((score / MAX_HANDS) * 100);
            const timeWindow = getTimeWindow();
            
            // Create bar chart visualization
            const maxBars = 10;
            const barsToFill = Math.round((score / MAX_HANDS) * maxBars);
            const barChart = '🟩'.repeat(barsToFill) + '⬜'.repeat(maxBars - barsToFill);
            
            const shareText = `🃏 The Nuts - Poker Challenge\n` +
                            `${timeWindow}\n\n` +
                            `${barChart}\n` +
                            `${score}/${MAX_HANDS} hands (${winPercentage}%)\n\n` +
                            `Can you beat my score?\n` +
                            `Play at: ${window.location.href}`;
            
            // Check if Web Share API is available (for mobile devices)
            if (navigator.share && /mobile|android|iphone|ipad|ipod/i.test(navigator.userAgent)) {
                // Use native share for mobile devices
                navigator.share({
                    title: 'The Nuts - Poker Challenge',
                    text: shareText
                }).then(() => {
                    // Successfully shared
                    console.log('Shared successfully');
                }).catch((error) => {
                    // User cancelled or error occurred, fall back to clipboard
                    if (error.name !== 'AbortError') {
                        copyToClipboard(shareText);
                    }
                });
            } else {
                // Desktop or no Web Share API support - copy to clipboard
                copyToClipboard(shareText);
            }
        }
        
        function copyToClipboard(text) {
            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showToast('Results copied to clipboard!');
                }).catch(err => {
                    // Fallback for older browsers
                    fallbackCopyToClipboard(text);
                });
            } else {
                // Use fallback method
                fallbackCopyToClipboard(text);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            showToast('Results copied to clipboard!');
        }
        
        function showToast(message) {
            const toast = document.getElementById('copied-toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        function showHelp() {
            document.getElementById('help-modal').classList.add('active');
        }

        function closeHelp() {
            document.getElementById('help-modal').classList.remove('active');
        }

        // Close modal when clicking outside
        document.getElementById('help-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeHelp();
            }
        });
    </script>
</body>
</html>